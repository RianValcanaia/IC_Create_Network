./src/path_manager.py
----------------------------------------
import os
from pathlib import Path

class PathManager:
    def __init__(self):
        # Base do projeto (assumindo que este arquivo est√° em src/)
        self.base_dir = Path(__file__).parent.parent.resolve()
        
        # Caminhos principais
        self.config_dir = self.base_dir / "config"
        self.network_dir = self.base_dir / "network"
        self.scripts_dir = self.base_dir / "scripts"
        self.templates_dir = self.base_dir / "template"
        self.versions_yaml = self.config_dir / "versions.yaml"
        
        # Arquivo de config
        self.network_yaml = self.config_dir / "network.yaml"

    def get_paths(self):
        """Retorna um dicion√°rio com todos os caminhos convertidos para string"""
        return {
            "BASE_DIR": str(self.base_dir),
            "NETWORK_DIR": str(self.network_dir),
            "SCRIPTS_DIR": str(self.scripts_dir),
            "CONFIG_FILE": str(self.network_yaml),
            "TEMPLATES_DIR": str(self.templates_dir),
        }

    def ensure_network_dirs(self):
        """Cria a estrutura de pastas dentro de network/ se n√£o existir"""
        subdirs = ["organizations", "channel-artifacts", "docker"]
        for sub in subdirs:
            (self.network_dir / sub).mkdir(parents=True, exist_ok=True)


./src/config_loader.py
----------------------------------------
# src/config_loader.py (Atualizado)
import yaml
import os

class ConfigLoader:
    def __init__(self, network_config_path, versions_config_path):
        self.network_config_path = network_config_path
        self.versions_config_path = versions_config_path
        self.full_config = {}

    def load(self):
        # 1. Carrega topologia da rede
        with open(self.network_config_path, 'r') as f:
            self.full_config['network_topology'] = yaml.safe_load(f)

        # 2. Carrega vers√µes
        if os.path.exists(self.versions_config_path):
            with open(self.versions_config_path, 'r') as f:
                self.full_config['env_versions'] = yaml.safe_load(f)
        else:
            raise FileNotFoundError("Arquivo versions.yaml n√£o encontrado!")

        print("‚úÖ Todas as configura√ß√µes carregadas.")
        return self.full_config


./src/__init__.py
----------------------------------------



./src/network_controller.py
----------------------------------------
import subprocess
import os

class NetworkController:
    def __init__(self, config, paths):
        self.config = config
        self.paths = paths # Inst√¢ncia do PathManager

    def _run_script(self, script_name, extra_env=None):
        script_path = os.path.join(self.paths.scripts_dir, script_name)
        
        # 1. Carrega vari√°veis base do sistema
        env = os.environ.copy()
        
        # 2. Injeta vari√°veis de vers√£o (Carregadas do YAML)
        env.update(self._get_env_vars())
        
        # 3. Injeta o caminho da pasta network (Do PathManager)
        env["NETWORK_DIR"] = str(self.paths.network_dir)

        # 4. Injeta vari√°veis extras espec√≠ficas da chamada
        if extra_env:
            env.update(extra_env)

        print(f"üöÄ Executando {script_name} (Fabric v{env['FABRIC_VERSION']})...")
        subprocess.run(["bash", script_path], check=True, env=env)

    def prepare_environment(self):
        # Cria as pastas necess√°rias
        self.paths.ensure_network_dirs()
        # Poderia chamar um script de limpeza aqui tamb√©m
        # self._run_script("00_cleanup.sh")

    def generate_crypto_material(self):
        """
        Gera certificados. 
        Aqui decidiremos se chamamos cryptogen ou Fabric-CA baseado no YAML.
        """
        print("--- Gerando Material Criptogr√°fico ---")
        
        # Exemplo: Passando nomes das orgs para o script (ou iterando)
        for org in self.config['organizations']:
            env = {
                "ORG_NAME": org['name'],
                "DOMAIN": self.config['network']['domain']
            }
            # Aqui chamariamos o script que gera crypto para essa org
            # self._run_script("01_generate_crypto.sh", env)
            print(f"Simulando cria√ß√£o de crypto para {org['name']}...")

    def create_network_structure(self):
        print("--- Criando Defini√ß√µes da Rede ---")
        # Aqui voc√™ geraria o configtx.yaml e docker-compose.yaml dinamicamente
        # baseado no self.config e salvaria em self.paths.network_dir

    def _get_env_vars(self):
        """Converte as configura√ß√µes de vers√£o em vari√°veis de ambiente"""
        versions = self.config['env_versions']['versions']
        images = self.config['env_versions']['images']
        
        # Caminho absoluto para a pasta bin do projeto
        project_bin_path = os.path.join(str(self.paths.base_dir), "bin")
        
        # Pega o PATH atual do sistema
        current_path = os.environ["PATH"]

        return {
            "FABRIC_VERSION": versions['fabric'],
            "CA_VERSION": versions['fabric_ca'],
            "GO_VERSION": versions['go'],
            "DOCKER_IMAGE_PREFIX": images['org_hyperledger'],
            # Vari√°veis √∫teis para os scripts
            "PATH": f"{project_bin_path}:{current_path}"
        }

    


./config/configtx.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

################################################################################
#
#   NOTE
#
#   Since release V3.0 Solo, Kafka and the System Channel have been removed
#   and are no longer supported.
#
################################################################################

---
################################################################################
#
#   ORGANIZATIONS
#
#   This section defines the organizational identities that can be referenced
#   in the configuration profiles.
#
################################################################################
Organizations:
  # SampleOrg defines an MSP using the sampleconfig. It should never be used
  # in production but may be used as a template for other definitions.
  - &SampleOrg
    # Name is the key by which this org will be referenced in channel
    # configuration transactions.
    # Name can include alphanumeric characters as well as dots and dashes.
    Name: SampleOrg

    # SkipAsForeign can be set to true for org definitions which are to be
    # inherited from the orderer system channel during channel creation.  This
    # is especially useful when an admin of a single org without access to the
    # MSP directories of the other orgs wishes to create a channel.  Note
    # this property must always be set to false for orgs included in block
    # creation.
    SkipAsForeign: false

    # ID is the key by which this org's MSP definition will be referenced.
    # ID can include alphanumeric characters as well as dots and dashes.
    ID: SampleOrg

    # MSPDir is the filesystem path which contains the MSP configuration.
    MSPDir: msp

    # Policies defines the set of policies at this level of the config tree
    # For organization policies, their canonical path is usually
    #   /Channel/<Application|Orderer>/<OrgName>/<PolicyName>
    Policies: &SampleOrgPolicies
      Readers:
        Type: Signature
        Rule: "OR('SampleOrg.member')"
        # If your MSP is configured with the new NodeOUs, you might
        # want to use a more specific rule like the following:
        # Rule: "OR('SampleOrg.admin', 'SampleOrg.peer', 'SampleOrg.client')"
      Writers:
        Type: Signature
        Rule: "OR('SampleOrg.member')"
        # If your MSP is configured with the new NodeOUs, you might
        # want to use a more specific rule like the following:
        # Rule: "OR('SampleOrg.admin', 'SampleOrg.client')"
      Admins:
        Type: Signature
        Rule: "OR('SampleOrg.admin')"
      Endorsement:
        Type: Signature
        Rule: "OR('SampleOrg.member')"

    # OrdererEndpoints is a list of all orderers this org runs which clients
    # and peers may to connect to push transactions and receive blocks respectively.
    OrdererEndpoints:
      - "127.0.0.1:7050"

################################################################################
#
#   CAPABILITIES
#
#   This section defines the capabilities of fabric network. This is a new
#   concept as of v1.1.0 and should not be utilized in mixed networks with
#   v1.0.x peers and orderers.  Capabilities define features which must be
#   present in a fabric binary for that binary to safely participate in the
#   fabric network.  For instance, if a new MSP type is added, newer binaries
#   might recognize and validate the signatures from this type, while older
#   binaries without this support would be unable to validate those
#   transactions.  This could lead to different versions of the fabric binaries
#   having different world states.  Instead, defining a capability for a channel
#   informs those binaries without this capability that they must cease
#   processing transactions until they have been upgraded.  For v1.0.x if any
#   capabilities are defined (including a map with all capabilities turned off)
#   then the v1.0.x peer will deliberately crash.
#
################################################################################
Capabilities:
  # Channel capabilities apply to both the orderers and the peers and must be
  # supported by both.
  # Set the value of the capability to true to require it.
  Channel: &ChannelCapabilities
    # V3.0 for Channel is a catchall flag for behavior which has been
    # determined to be desired for all orderers and peers running at the v3.0.0
    # level, but which would be incompatible with orderers and peers from
    # prior releases.
    # Prior to enabling V3.0 channel capabilities, ensure that all
    # orderers and peers on a channel are at v3.0.0 or later.
    V3_0: true

  # Orderer capabilities apply only to the orderers, and may be safely
  # used with prior release peers.
  # Set the value of the capability to true to require it.
  Orderer: &OrdererCapabilities
    # V1.1 for Orderer is a catchall flag for behavior which has been
    # determined to be desired for all orderers running at the v1.1.x
    # level, but which would be incompatible with orderers from prior releases.
    # Prior to enabling V2.0 orderer capabilities, ensure that all
    # orderers on a channel are at v2.0.0 or later.
    V2_0: true

  # Application capabilities apply only to the peer network, and may be safely
  # used with prior release orderers.
  # Set the value of the capability to true to require it.
  Application: &ApplicationCapabilities
    # V2.5 for Application enables the new non-backwards compatible
    # features of fabric v2.5, namely the ability to purge private data.
    # Prior to enabling V2.5 application capabilities, ensure that all
    # peers on a channel are at v2.5.0 or later.
    V2_5: true

################################################################################
#
#   APPLICATION
#
#   This section defines the values to encode into a config transaction or
#   genesis block for application-related parameters.
#
################################################################################
Application: &ApplicationDefaults
  ACLs: &ACLsDefault
    # This section provides defaults for policies for various resources
    # in the system. These "resources" could be functions on system chaincodes
    # (e.g., "GetBlockByNumber" on the "qscc" system chaincode) or other resources
    # (e.g.,who can receive Block events). This section does NOT specify the resource's
    # definition or API, but just the ACL policy for it.
    #
    # Users can override these defaults with their own policy mapping by defining the
    # mapping under ACLs in their channel definition

    #---New Lifecycle System Chaincode (_lifecycle) function to policy mapping for access control--#

    # ACL policy for _lifecycle's "CheckCommitReadiness" function
    _lifecycle/CheckCommitReadiness: /Channel/Application/Writers

    # ACL policy for _lifecycle's "CommitChaincodeDefinition" function
    _lifecycle/CommitChaincodeDefinition: /Channel/Application/Writers

    # ACL policy for _lifecycle's "QueryChaincodeDefinition" function
    _lifecycle/QueryChaincodeDefinition: /Channel/Application/Writers

    # ACL policy for _lifecycle's "QueryChaincodeDefinitions" function
    _lifecycle/QueryChaincodeDefinitions: /Channel/Application/Writers

    #---Lifecycle System Chaincode (lscc) function to policy mapping for access control---#

    # ACL policy for lscc's "getid" function
    lscc/ChaincodeExists: /Channel/Application/Readers

    # ACL policy for lscc's "getdepspec" function
    lscc/GetDeploymentSpec: /Channel/Application/Readers

    # ACL policy for lscc's "getccdata" function
    lscc/GetChaincodeData: /Channel/Application/Readers

    # ACL Policy for lscc's "getchaincodes" function
    lscc/GetInstantiatedChaincodes: /Channel/Application/Readers

    #---Query System Chaincode (qscc) function to policy mapping for access control---#

    # ACL policy for qscc's "GetChainInfo" function
    qscc/GetChainInfo: /Channel/Application/Readers

    # ACL policy for qscc's "GetBlockByNumber" function
    qscc/GetBlockByNumber: /Channel/Application/Readers

    # ACL policy for qscc's  "GetBlockByHash" function
    qscc/GetBlockByHash: /Channel/Application/Readers

    # ACL policy for qscc's "GetTransactionByID" function
    qscc/GetTransactionByID: /Channel/Application/Readers

    # ACL policy for qscc's "GetBlockByTxID" function
    qscc/GetBlockByTxID: /Channel/Application/Readers

    #---Configuration System Chaincode (cscc) function to policy mapping for access control---#

    # ACL policy for cscc's "GetConfigBlock" function
    cscc/GetConfigBlock: /Channel/Application/Readers

    # ACL policy for cscc's "GetChannelConfig" function
    cscc/GetChannelConfig: /Channel/Application/Readers

    #---Miscellaneous peer function to policy mapping for access control---#

    # ACL policy for invoking chaincodes on peer
    peer/Propose: /Channel/Application/Writers

    # ACL policy for chaincode to chaincode invocation
    peer/ChaincodeToChaincode: /Channel/Application/Writers

    #---Events resource to policy mapping for access control###---#

    # ACL policy for sending block events
    event/Block: /Channel/Application/Readers

    # ACL policy for sending filtered block events
    event/FilteredBlock: /Channel/Application/Readers

  # Organizations lists the orgs participating on the application side of the
  # network.
  Organizations:

  # Policies defines the set of policies at this level of the config tree
  # For Application policies, their canonical path is
  #   /Channel/Application/<PolicyName>
  Policies: &ApplicationDefaultPolicies
    LifecycleEndorsement:
      Type: ImplicitMeta
      Rule: "MAJORITY Endorsement"
    Endorsement:
      Type: ImplicitMeta
      Rule: "MAJORITY Endorsement"
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"

  # Capabilities describes the application level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *ApplicationCapabilities

################################################################################
#
#   ORDERER
#
#   This section defines the values to encode into a config transaction or
#   genesis block for orderer related parameters.
#
################################################################################
Orderer: &OrdererDefaults
  # Orderer Type: The orderer implementation to start.
  # Available types are "etcdraft" and "BFT".
  # Please note that "solo" and "kafka" are no longer supported.
  OrdererType: etcdraft

  # Addresses used to be the list of orderer addresses that clients and peers
  # could connect to.  However, this does not allow clients to associate orderer
  # addresses and orderer organizations which can be useful for things such
  # as TLS validation.  The preferred way to specify orderer addresses is now
  # to include the OrdererEndpoints item in your org definition
  Addresses:
    # - 127.0.0.1:7050

  # Batch Timeout: The amount of time to wait before creating a batch.
  BatchTimeout: 2s

  # Batch Size: Controls the number of messages batched into a block.
  # The orderer views messages opaquely, but typically, messages may
  # be considered to be Fabric transactions.  The 'batch' is the group
  # of messages in the 'data' field of the block.  Blocks will be a few kb
  # larger than the batch size, when signatures, hashes, and other metadata
  # is applied.
  BatchSize:
    # Max Message Count: The maximum number of messages to permit in a
    # batch.  No block will contain more than this number of messages.
    MaxMessageCount: 500

    # Absolute Max Bytes: The absolute maximum number of bytes allowed for
    # the serialized messages in a batch. The maximum block size is this value
    # plus the size of the associated metadata (usually a few KB depending
    # upon the size of the signing identities). Any transaction larger than
    # this value will be rejected by ordering.
    # It is recommended not to exceed 49 MB, given the default grpc max message size of 100 MB
    # configured on orderer and peer nodes (and allowing for message expansion during communication).
    AbsoluteMaxBytes: 10 MB

    # Preferred Max Bytes: The preferred maximum number of bytes allowed
    # for the serialized messages in a batch. Roughly, this field may be considered
    # the best effort maximum size of a batch. A batch will fill with messages
    # until this size is reached (or the max message count, or batch timeout is
    # exceeded).  If adding a new message to the batch would cause the batch to
    # exceed the preferred max bytes, then the current batch is closed and written
    # to a block, and a new batch containing the new message is created.  If a
    # message larger than the preferred max bytes is received, then its batch
    # will contain only that message.  Because messages may be larger than
    # preferred max bytes (up to AbsoluteMaxBytes), some batches may exceed
    # the preferred max bytes, but will always contain exactly one transaction.
    PreferredMaxBytes: 2 MB

  # Max Channels is the maximum number of channels to allow on the ordering
  # network. When set to 0, this implies no maximum number of channels.
  MaxChannels: 0

  # ConsenterMapping contains the definition of consenter identity, endpoints, and crypto material.
  # The ConsenterMapping is used in the BFT consensus protocol, and should include enough servers to ensure
  # fault-tolerance; In BFT this number is at least 3*F+1, where F is the number of potential failures.
  # In BFT it is highly recommended that the addresses for delivery & broadcast (the OrdererEndpoints item in the
  # org definition) map 1:1 to the Orderer/ConsenterMapping (for cluster consensus). That is, every consenter should
  # be represented by a delivery endpoint. Note that in BFT (V3) global Orderer/Addresses are no longer supported.
  ConsenterMapping:
    - ID: 1
      Host: bft0.example.com
      Port: 7050
      MSPID: OrdererOrg1
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert0
      ServerTLSCert: path/to/ServerTLSCert0
    - ID: 2
      Host: bft1.example.com
      Port: 7050
      MSPID: OrdererOrg2
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert1
      ServerTLSCert: path/to/ServerTLSCert1
    - ID: 3
      Host: bft2.example.com
      Port: 7050
      MSPID: OrdererOrg3
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert2
      ServerTLSCert: path/to/ServerTLSCert2
    - ID: 4
      Host: bft3.example.com
      Port: 7050
      MSPID: OrdererOrg4
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert3
      ServerTLSCert: path/to/ServerTLSCert3

  # EtcdRaft defines configuration which must be set when the "etcdraft"
  # orderertype is chosen.
  EtcdRaft:
    # The set of Raft replicas for this network. For the etcd/raft-based
    # implementation, we expect every replica to also be an OSN. Therefore,
    # a subset of the host:port items enumerated in this list should be
    # replicated under the Orderer.Addresses key above.
    Consenters:
      - Host: raft0.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert0
        ServerTLSCert: path/to/ServerTLSCert0
      - Host: raft1.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert1
        ServerTLSCert: path/to/ServerTLSCert1
      - Host: raft2.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert2
        ServerTLSCert: path/to/ServerTLSCert2

    # Options to be specified for all the etcd/raft nodes. The values here
    # are the defaults for all new channels and can be modified on a
    # per-channel basis via configuration updates.
    Options:
      # TickInterval is the time interval between two Node.Tick invocations.
      TickInterval: 500ms

      # ElectionTick is the number of Node.Tick invocations that must pass
      # between elections. That is, if a follower does not receive any
      # message from the leader of current term before ElectionTick has
      # elapsed, it will become candidate and start an election.
      # ElectionTick must be greater than HeartbeatTick.
      ElectionTick: 10

      # HeartbeatTick is the number of Node.Tick invocations that must
      # pass between heartbeats. That is, a leader sends heartbeat
      # messages to maintain its leadership every HeartbeatTick ticks.
      HeartbeatTick: 1

      # MaxInflightBlocks limits the max number of in-flight append messages
      # during optimistic replication phase.
      MaxInflightBlocks: 5

      # SnapshotIntervalSize defines number of bytes per which a snapshot is taken
      SnapshotIntervalSize: 16 MB

  # Organizations lists the orgs participating on the orderer side of the
  # network.
  Organizations:

  # Policies defines the set of policies at this level of the config tree
  # For Orderer policies, their canonical path is
  #   /Channel/Orderer/<PolicyName>
  Policies:
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"
    # BlockValidation specifies what signatures must be included in the block
    # from the orderer for the peer to validate it.
    BlockValidation:
      Type: ImplicitMeta
      Rule: "ANY Writers"

  # Capabilities describes the orderer level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *OrdererCapabilities

################################################################################
#
#   CHANNEL
#
#   This section defines the values to encode into a config transaction or
#   genesis block for channel related parameters.
#
################################################################################
Channel: &ChannelDefaults
  # Policies defines the set of policies at this level of the config tree
  # For Channel policies, their canonical path is
  #   /Channel/<PolicyName>
  Policies:
    # Who may invoke the 'Deliver' API
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    # Who may invoke the 'Broadcast' API
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    # By default, who may modify elements at this config level
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"

  # Capabilities describes the channel level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *ChannelCapabilities

################################################################################
#
#   PROFILES
#
#   Different configuration profiles may be encoded here to be specified as
#   parameters to the configtxgen tool. The profiles which specify consortiums
#   are to be used for generating the orderer genesis block. With the correct
#   consortium members defined in the orderer genesis block, channel creation
#   requests may be generated with only the org member names and a consortium
#   name.
#
################################################################################
Profiles:
  # SampleSingleMSPSolo defines a configuration which uses the Solo orderer,
  # and contains a single MSP definition (the MSP sampleconfig).
  # The Consortium SampleConsortium has only a single member, SampleOrg.
  SampleSingleMSPSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
      Organizations:
        - *SampleOrg
    Consortiums:
      SampleConsortium:
        Organizations:
          - *SampleOrg

  # SampleInsecureSolo defines a configuration which uses the Solo orderer,
  # contains no MSP definitions, and allows all transactions and channel
  # creation requests for the consortium SampleConsortium.
  SampleInsecureSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
    Consortiums:
      SampleConsortium:
        Organizations:

  # SampleDevModeSolo defines a configuration which uses the Solo orderer,
  # contains the sample MSP as both orderer and consortium member, and
  # requires only basic membership for admin privileges. It also defines
  # an Application on the ordering system channel, which should usually
  # be avoided.
  SampleDevModeSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Consortiums:
      SampleConsortium:
        Organizations:
          - <<: *SampleOrg
            Policies:
              <<: *SampleOrgPolicies
              Admins:
                Type: Signature
                Rule: "OR('SampleOrg.member')"


  # SampleSingleMSPChannel defines a channel with only the sample org as a
  # member. It is designed to be used in conjunction with SampleSingleMSPSolo
  # orderer profile. Note, for channel creation profiles, only the
  # 'Application' section and consortium # name are considered.
  SampleSingleMSPChannel:
    <<: *ChannelDefaults
    Consortium: SampleConsortium
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg

  # SampleDevModeEtcdRaft defines a configuration that differs from the
  # SampleDevModeSolo one only in that it uses the etcd/raft-based orderer.
  SampleDevModeEtcdRaft:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Consortiums:
      SampleConsortium:
        Organizations:
          - <<: *SampleOrg
            Policies:
              <<: *SampleOrgPolicies
              Admins:
                Type: Signature
                Rule: "OR('SampleOrg.member')"

  # SampleAppChannelInsecureSolo defines an application channel configuration
  # which uses the Solo orderer and contains no MSP definitions.
  SampleAppChannelInsecureSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
    Application:
      <<: *ApplicationDefaults

  # SampleAppChannelEtcdRaft defines an application channel configuration
  # that uses the etcd/raft-based orderer.
  SampleAppChannelEtcdRaft:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
          OrdererEndpoints:
            - "127.0.0.1:7050"
            - "127.0.0.1:7051"
            - "127.0.0.1:7052"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"

  # SampleAppChannelSmartBft defines an application channel configuration
  # that uses the Smart BFT orderer.
  SampleAppChannelSmartBft:
    <<: *ChannelDefaults
    Consortium: SampleConsortium
    Orderer:
      <<: *OrdererDefaults
      OrdererType: BFT
      BatchSize:
        MaxMessageCount: 5000
        AbsoluteMaxBytes: 10 MB
      SmartBFT:
        RequestBatchMaxInterval: 200ms
        RequestForwardTimeout: 5s
        RequestComplainTimeout: 20s
        RequestAutoRemoveTimeout: 3m0s
        ViewChangeResendInterval: 5s
        ViewChangeTimeout: 20s
        LeaderHeartbeatTimeout: 1m0s
        CollectTimeout: 1s
        IncomingMessageBufferSize: 200
        RequestPoolSize: 100000
        LeaderHeartbeatCount: 10
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"



./config/core.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

###############################################################################
#
#    Peer section
#
###############################################################################
peer:
  # The peer id provides a name for this peer instance and is used when
  # naming docker resources.
  id: jdoe

  # The networkId allows for logical separation of networks and is used when
  # naming docker resources.
  networkId: dev

  # The Address at local network interface this Peer will listen on.
  # By default, it will listen on all network interfaces
  listenAddress: 0.0.0.0:7051

  # The endpoint this peer uses to listen for inbound chaincode connections.
  # If this is commented-out, the listen address is selected to be
  # the peer's address (see below) with port 7052
  # chaincodeListenAddress: 0.0.0.0:7052

  # The endpoint the chaincode for this peer uses to connect to the peer.
  # If this is not specified, the chaincodeListenAddress address is selected.
  # And if chaincodeListenAddress is not specified, address is selected from
  # peer address (see below). If specified peer address is invalid then it
  # will fallback to the auto detected IP (local IP) regardless of the peer
  # addressAutoDetect value.
  # chaincodeAddress: 0.0.0.0:7052

  # When used as peer config, this represents the endpoint to other peers
  # in the same organization. For peers in other organization, see
  # gossip.externalEndpoint for more info.
  # When used as CLI config, this means the peer's endpoint to interact with
  address: 0.0.0.0:7051

  # Whether the Peer should programmatically determine its address
  # This case is useful for docker containers.
  # When set to true, will override peer address.
  addressAutoDetect: false

  # Settings for the Peer's gateway server.
  gateway:
    # Whether the gateway is enabled for this Peer.
    enabled: true
    # endorsementTimeout is the duration the gateway waits for a response
    # from other endorsing peers before returning a timeout error to the client.
    endorsementTimeout: 30s
    # broadcastTimeout is the duration the gateway waits for a response
    # from ordering nodes before returning a timeout error to the client.
    broadcastTimeout: 30s
    # dialTimeout is the duration the gateway waits for a connection
    # to other network nodes.
    dialTimeout: 2m

  # Keepalive settings for peer server and clients
  keepalive:
    # Interval is the duration after which if the server does not see
    # any activity from the client it pings the client to see if it's alive
    interval: 7200s
    # Timeout is the duration the server waits for a response
    # from the client after sending a ping before closing the connection
    timeout: 20s
    # MinInterval is the minimum permitted time between client pings.
    # If clients send pings more frequently, the peer server will
    # disconnect them
    minInterval: 60s
    # Client keepalive settings for communicating with other peer nodes
    client:
      # Interval is the time between pings to peer nodes.  This must
      # greater than or equal to the minInterval specified by peer
      # nodes
      interval: 60s
      # Timeout is the duration the client waits for a response from
      # peer nodes before closing the connection
      timeout: 20s
    # DeliveryClient keepalive settings for communication with ordering
    # nodes.
    deliveryClient:
      # Interval is the time between pings to ordering nodes.  This must
      # greater than or equal to the minInterval specified by ordering
      # nodes.
      interval: 60s
      # Timeout is the duration the client waits for a response from
      # ordering nodes before closing the connection
      timeout: 20s

  # Gossip related configuration
  gossip:
    # Bootstrap set to initialize gossip with.
    # This is a list of other peers that this peer reaches out to at startup.
    # Important: The endpoints here have to be endpoints of peers in the same
    # organization, because the peer would refuse connecting to these endpoints
    # unless they are in the same organization as the peer.
    bootstrap: 127.0.0.1:7051

    # NOTE: orgLeader and useLeaderElection parameters are mutual exclusive.
    # Setting both to true would result in the termination of the peer
    # since this is undefined state. If the peers are configured with
    # useLeaderElection=false, make sure there is at least 1 peer in the
    # organization that its orgLeader is set to true.

    # Defines whenever peer will initialize dynamic algorithm for
    # "leader" selection, where leader is the peer to establish
    # connection with ordering service and use delivery protocol
    # to pull ledger blocks from ordering service.
    useLeaderElection: false
    # Statically defines peer to be an organization "leader".
    # Organization leaders maintain connection with ordering service
    # and pulls blocks as they are created. Optionally, leader peers
    # may disseminate pulled blocks to peers in its own organization
    # based on the peer.deliveryclient.blockGossipEnabled setting below.
    # Multiple peers or all peers in an organization
    # may be configured as org leaders, so that they all pull
    # blocks directly from ordering service.
    orgLeader: true

    # Interval for membershipTracker polling
    membershipTrackerInterval: 5s

    # Overrides the endpoint that the peer publishes to peers
    # in its organization. For peers in foreign organizations
    # see 'externalEndpoint'
    endpoint:
    # Maximum count of blocks stored in memory
    maxBlockCountToStore: 10
    # Max time between consecutive message pushes(unit: millisecond)
    maxPropagationBurstLatency: 10ms
    # Max number of messages stored until a push is triggered to remote peers
    maxPropagationBurstSize: 10
    # Number of times a message is pushed to remote peers
    propagateIterations: 1
    # Number of peers selected to push messages to
    propagatePeerNum: 3
    # Determines frequency of pull phases(unit: second)
    # Must be greater than digestWaitTime + responseWaitTime
    pullInterval: 4s
    # Number of peers to pull from
    pullPeerNum: 3
    # Determines frequency of pulling state info messages from peers(unit: second)
    requestStateInfoInterval: 4s
    # Determines frequency of pushing state info messages to peers(unit: second)
    publishStateInfoInterval: 4s
    # Maximum time a stateInfo message is kept until expired
    stateInfoRetentionInterval:
    # Time from startup certificates are included in Alive messages(unit: second)
    publishCertPeriod: 10s
    # Should we skip verifying block messages or not (currently not in use)
    skipBlockVerification: false
    # Dial timeout(unit: second)
    dialTimeout: 3s
    # Connection timeout(unit: second)
    connTimeout: 2s
    # Buffer size of received messages
    recvBuffSize: 20
    # Buffer size of sending messages
    sendBuffSize: 200
    # Time to wait before pull engine processes incoming digests (unit: second)
    # Should be slightly smaller than requestWaitTime
    digestWaitTime: 1s
    # Time to wait before pull engine removes incoming nonce (unit: milliseconds)
    # Should be slightly bigger than digestWaitTime
    requestWaitTime: 1500ms
    # Time to wait before pull engine ends pull (unit: second)
    responseWaitTime: 2s
    # Alive check interval(unit: second)
    aliveTimeInterval: 5s
    # Alive expiration timeout(unit: second)
    aliveExpirationTimeout: 25s
    # Reconnect interval(unit: second)
    reconnectInterval: 25s
    # Max number of attempts to connect to a peer
    maxConnectionAttempts: 120
    # Message expiration factor for alive messages
    msgExpirationFactor: 20
    # This is an endpoint that is published to peers outside of the organization.
    # If this isn't set, the peer will not be known to other organizations and will not be exposed via service discovery.
    externalEndpoint:
    # Leader election service configuration
    election:
      # Longest time peer waits for stable membership during leader election startup (unit: second)
      startupGracePeriod: 15s
      # Interval gossip membership samples to check its stability (unit: second)
      membershipSampleInterval: 1s
      # Time passes since last declaration message before peer decides to perform leader election (unit: second)
      leaderAliveThreshold: 10s
      # Time between peer sends propose message and declares itself as a leader (sends declaration message) (unit: second)
      leaderElectionDuration: 5s

    pvtData:
      # pullRetryThreshold determines the maximum duration of time private data corresponding for a given block
      # would be attempted to be pulled from peers until the block would be committed without the private data
      pullRetryThreshold: 60s
      # As private data enters the transient store, it is associated with the peer's ledger's height at that time.
      # transientstoreMaxBlockRetention defines the maximum difference between the current ledger's height upon commit,
      # and the private data residing inside the transient store that is guaranteed not to be purged.
      # Private data is purged from the transient store when blocks with sequences that are multiples
      # of transientstoreMaxBlockRetention are committed.
      transientstoreMaxBlockRetention: 20000
      # pushAckTimeout is the maximum time to wait for an acknowledgement from each peer
      # at private data push at endorsement time.
      pushAckTimeout: 3s
      # Block to live pulling margin, used as a buffer
      # to prevent peer from trying to pull private data
      # from peers that is soon to be purged in next N blocks.
      # This helps a newly joined peer catch up to current
      # blockchain height quicker.
      btlPullMargin: 10
      # the process of reconciliation is done in an endless loop, while in each iteration reconciler tries to
      # pull from the other peers the most recent missing blocks with a maximum batch size limitation.
      # reconcileBatchSize determines the maximum batch size of missing private data that will be reconciled in a
      # single iteration.
      reconcileBatchSize: 10
      # reconcileSleepInterval determines the time reconciler sleeps from end of an iteration until the beginning
      # of the next reconciliation iteration.
      reconcileSleepInterval: 1m
      # reconciliationEnabled is a flag that indicates whether private data reconciliation is enable or not.
      reconciliationEnabled: true
      # skipPullingInvalidTransactionsDuringCommit is a flag that indicates whether pulling of invalid
      # transaction's private data from other peers need to be skipped during the commit time and pulled
      # only through reconciler.
      skipPullingInvalidTransactionsDuringCommit: false
      # implicitCollectionDisseminationPolicy specifies the dissemination  policy for the peer's own implicit collection.
      # When a peer endorses a proposal that writes to its own implicit collection, below values override the default values
      # for disseminating private data.
      # Note that it is applicable to all channels the peer has joined. The implication is that requiredPeerCount has to
      # be smaller than the number of peers in a channel that has the lowest numbers of peers from the organization.
      implicitCollectionDisseminationPolicy:
        # requiredPeerCount defines the minimum number of eligible peers to which the peer must successfully
        # disseminate private data for its own implicit collection during endorsement. Default value is 0.
        requiredPeerCount: 0
        # maxPeerCount defines the maximum number of eligible peers to which the peer will attempt to
        # disseminate private data for its own implicit collection during endorsement. Default value is 1.
        maxPeerCount: 1

    # Gossip state transfer related configuration
    state:
      # Indicates whether state transfer is enabled.
      # State transfer enabled allows a peer that is not a leader
      # to sync up missed blocks from other peers.
      # Default value is false since the recommended value of peer.gossip.orgleader is true.
      # Keep in mind that when peer.gossip.useLeaderElection is true
      # and there are several peers in the organization,
      # or peer.gossip.useLeaderElection is false alongside with
      # peer.gossip.orgleader being false, the peer's ledger may lag behind
      # the rest of the peers and will never catch up due to state transfer
      # being disabled.
      enabled: false
      # checkInterval interval to check whether peer is lagging behind enough to
      # request blocks via state transfer from another peer.
      checkInterval: 10s
      # responseTimeout amount of time to wait for state transfer response from
      # other peers
      responseTimeout: 3s
      # batchSize the number of blocks to request via state transfer from another peer
      batchSize: 10
      # blockBufferSize reflects the size of the re-ordering buffer
      # which captures blocks and takes care to deliver them in order
      # down to the ledger layer. The actual buffer size is bounded between
      # 0 and 2*blockBufferSize, each channel maintains its own buffer
      blockBufferSize: 20
      # maxRetries maximum number of re-tries to ask
      # for single state transfer request
      maxRetries: 3

  # TLS Settings
  tls:
    # Require server-side TLS
    enabled: false
    # Require client certificates / mutual TLS for inbound connections.
    # Note that clients that are not configured to use a certificate will
    # fail to connect to the peer.
    clientAuthRequired: false
    # X.509 certificate used for TLS server
    cert:
      file: tls/server.crt
    # Private key used for TLS server
    key:
      file: tls/server.key
    # rootcert.file represents the trusted root certificate chain used for verifying certificates
    # of other nodes during outbound connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    rootcert:
      file: tls/ca.crt
    # If mutual TLS is enabled, clientRootCAs.files contains a list of additional root certificates
    # used for verifying certificates of client connections.
    # It augments the set of TLS CA certificates available from the MSPs of each channel‚Äôs configuration.
    # Minimally, set your organization's TLS CA root certificate so that the peer can receive join channel requests.
    clientRootCAs:
      files:
        - tls/ca.crt
    # Private key used for TLS when making client connections.
    # If not set, peer.tls.key.file will be used instead
    clientKey:
      file:
    # X.509 certificate used for TLS when making client connections.
    # If not set, peer.tls.cert.file will be used instead
    clientCert:
      file:

  # Authentication contains configuration parameters related to authenticating
  # client messages
  authentication:
    # the acceptable difference between the current server time and the
    # client's time as specified in a client request message
    # this value is used for delivery service and
    # endorsement service (if the authFilter is enabled)
    timewindow: 15m

  # Path on the file system where peer will store data (eg ledger). This
  # location must be access control protected to prevent unintended
  # modification that might corrupt the peer operations.
  # The path may be relative to FABRIC_CFG_PATH or an absolute path.
  fileSystemPath: /var/hyperledger/production

  # BCCSP (Blockchain crypto provider): Select which crypto implementation or
  # library to use
  BCCSP:
    Default: SW
    # Settings for the SW crypto provider (i.e. when DEFAULT: SW)
    SW:
      # TODO: The default Hash and Security level needs refactoring to be
      # fully configurable. Changing these defaults requires coordination
      # SHA2 is hardcoded in several places, not only BCCSP
      Hash: SHA2
      Security: 256
      # Location of Key Store
      FileKeyStore:
        # If "", defaults to 'mspConfigPath'/keystore
        KeyStore:
    # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)
    PKCS11:
      # Location of the PKCS11 module library
      Library:
      # Token Label
      Label:
      # User PIN
      Pin:
      Hash:
      Security:
      SoftwareVerify:
      Immutable:
      AltID:
      KeyIds:

  # Path on the file system where peer will find MSP local configurations
  # The path may be relative to FABRIC_CFG_PATH or an absolute path.
  mspConfigPath: msp

  # Identifier of the local MSP
  # ----!!!!IMPORTANT!!!-!!!IMPORTANT!!!-!!!IMPORTANT!!!!----
  # Deployers need to change the value of the localMspId string.
  # In particular, the name of the local MSP ID of a peer needs
  # to match the name of one of the MSPs in each of the channel
  # that this peer is a member of. Otherwise this peer's messages
  # will not be identified as valid by other nodes.
  localMspId: SampleOrg

  # CLI common client config options
  client:
    # connection timeout
    connTimeout: 3s

  # Delivery service related config
  deliveryclient:
    # Enables this peer to disseminate blocks it pulls from the ordering service
    # to other peers in the same organization via gossip.
    # Note that 'gossip.state.enabled' controls point to point block replication
    # of blocks committed in the past.
    blockGossipEnabled: false
    # It sets the total time the delivery service may spend in reconnection
    # attempts until its retry logic gives up and returns an error,
    # ignored if peer is a static leader
    reconnectTotalTimeThreshold: 3600s

    # It sets the delivery service <-> ordering service node connection timeout
    connTimeout: 3s

    # It sets the delivery service maximal delay between consecutive retries.
    # Time between retries will have exponential backoff until hitting this threshold.
    reConnectBackoffThreshold: 3600s

    # If a certain header from a header receiver is in front of the block receiver for more that this time, a
    # censorship event is declared and the block source is changed.
    blockCensorshipTimeoutKey: 30s

    # The initial value of the actual retry interval, which is increased on every failed retry
    minimalReconnectInterval: 100ms

    # A list of orderer endpoint addresses which should be overridden
    # when found in channel configurations.
    addressOverrides:
      # - from:
      #   to:
      #   caCertsFile:
      # - from:
      #   to:
      #   caCertsFile:

    # Determines which delivery client will be used when consensus type is "BFT"
    # (when consensus type is "etcdraft" this key is ignored).
    # "simple" - use CFT deliverer
    # "cluster" - use BFT deliverer
    policy: cluster

  # Type for the local MSP - by default it's of type bccsp
  localMspType: bccsp

  # Used with Go profiling tools only in none production environment. In
  # production, it should be disabled (eg enabled: false)
  profile:
    enabled: false
    listenAddress: 0.0.0.0:6060

  # Handlers defines custom handlers that can filter and mutate
  # objects passing within the peer, such as:
  #   Auth filter - reject or forward proposals from clients
  #   Decorators  - append or mutate the chaincode input passed to the chaincode
  #   Endorsers   - Custom signing over proposal response payload and its mutation
  # Valid handler definition contains:
  #   - A name which is a factory method name defined in
  #     core/handlers/library/library.go for statically compiled handlers
  #   - library path to shared object binary for pluggable filters
  # Auth filters and decorators are chained and executed in the order that
  # they are defined. For example:
  # authFilters:
  #   - name: FilterOne
  #     library: /opt/lib/filter.so
  #   - name: FilterTwo
  # decorators:
  #   - name: DecoratorOne
  #   - name: DecoratorTwo
  #     library: /opt/lib/decorator.so
  # Endorsers are configured as a map that its keys are the endorsement system chaincodes that are being overridden.
  # Below is an example that overrides the default ESCC and uses an endorsement plugin that has the same functionality
  # as the default ESCC.
  # If the 'library' property is missing, the name is used as the constructor method in the builtin library similar
  # to auth filters and decorators.
  # endorsers:
  #   escc:
  #     name: DefaultESCC
  #     library: /etc/hyperledger/fabric/plugin/escc.so
  handlers:
    authFilters:
      - name: DefaultAuth
      - name: ExpirationCheck # This filter checks identity x509 certificate expiration
      - name: TimeWindowCheck # This filter checks the timestamp of an proposal request with the peer.authentication.timewindow parameter from core.yaml
    decorators:
      - name: DefaultDecorator
    endorsers:
      escc:
        name: DefaultEndorsement
        library:
    validators:
      vscc:
        name: DefaultValidation
        library:

        # library: /etc/hyperledger/fabric/plugin/escc.so
  # Number of goroutines that will execute transaction validation in parallel.
  # By default, the peer chooses the number of CPUs on the machine. Set this
  # variable to override that choice.
  # NOTE: overriding this value might negatively influence the performance of
  # the peer so please change this value only if you know what you're doing
  validatorPoolSize:

  # The discovery service is used by clients to query information about peers,
  # such as - which peers have joined a certain channel, what is the latest
  # channel config, and most importantly - given a chaincode and a channel,
  # what possible sets of peers satisfy the endorsement policy.
  discovery:
    enabled: true
    # Whether the authentication cache is enabled or not.
    authCacheEnabled: true
    # The maximum size of the cache, after which a purge takes place
    authCacheMaxSize: 1000
    # The proportion (0 to 1) of entries that remain in the cache after the cache is purged due to overpopulation
    authCachePurgeRetentionRatio: 0.75
    # Whether to allow non-admins to perform non channel scoped queries.
    # When this is false, it means that only peer admins can perform non channel scoped queries.
    orgMembersAllowedAccess: false

  # Limits is used to configure some internal resource limits.
  limits:
    # Concurrency limits the number of concurrently running requests to a service on each peer.
    # Currently this option is only applied to endorser service and deliver service.
    # When the property is missing or the value is 0, the concurrency limit is disabled for the service.
    concurrency:
      # endorserService limits concurrent requests to endorser service that handles chaincode deployment, query and invocation,
      # including both user chaincodes and system chaincodes.
      endorserService: 2500
      # deliverService limits concurrent event listeners registered to deliver service for blocks and transaction events.
      deliverService: 2500
      # gatewayService limits concurrent requests to gateway service that handles the submission and evaluation of transactions.
      gatewayService: 500

  # Since all nodes should be consistent it is recommended to keep
  # the default value of 100MB for MaxRecvMsgSize & MaxSendMsgSize
  # Max message size in bytes GRPC server and client can receive
  maxRecvMsgSize: 104857600
  # Max message size in bytes GRPC server and client can send
  maxSendMsgSize: 104857600

###############################################################################
#
#    VM section
#
###############################################################################
vm:
  # Endpoint of the vm management system.  For docker can be one of the following in general
  # unix:///var/run/docker.sock
  # http://localhost:2375
  # https://localhost:2376
  # If you utilize external chaincode builders and don't need the default Docker chaincode builder,
  # the endpoint should be unconfigured so that the peer's Docker health checker doesn't get registered.
  endpoint: unix:///var/run/docker.sock

  # settings for docker vms
  docker:
    tls:
      enabled: false
      ca:
        file: docker/ca.crt
      cert:
        file: docker/tls.crt
      key:
        file: docker/tls.key

    # Enables/disables the standard out/err from chaincode containers for
    # debugging purposes
    attachStdout: false

    # Parameters on creating docker container.
    # Container may be efficiently created using ipam & dns-server for cluster
    # NetworkMode - sets the networking mode for the container. Supported
    # standard values are: `host`(default),`bridge`,`ipvlan`,`none`.
    # Dns - a list of DNS servers for the container to use.
    # Note:  `Privileged` `Binds` `Links` and `PortBindings` properties of
    # Docker Host Config are not supported and will not be used if set.
    # LogConfig - sets the logging driver (Type) and related options
    # (Config) for Docker. For more info,
    # https://docs.docker.com/engine/admin/logging/overview/
    # Note: Set LogConfig using Environment Variables is not supported.
    hostConfig:
      NetworkMode: host
      Dns:
        # - 192.168.0.1
      LogConfig:
        Type: json-file
        Config:
          max-size: "50m"
          max-file: "5"
      Memory: 2147483648

###############################################################################
#
#    Chaincode section
#
###############################################################################
chaincode:
  # The id is used by the Chaincode stub to register the executing Chaincode
  # ID with the Peer and is generally supplied through ENV variables
  # the `path` form of ID is provided when installing the chaincode.
  # The `name` is used for all other requests and can be any string.
  id:
    path:
    name:

  # Generic builder image with Go pre-installed.
  # TWO_DIGIT_VERSION represents Fabric major.minor version.
  builder: $(DOCKER_NS)/fabric-ccenv:$(TWO_DIGIT_VERSION)

  # Enables/disables force pulling of the base docker images (listed below)
  # during user chaincode instantiation.
  # Useful when using moving image tags (such as :latest)
  pull: false

  golang:
    # Compiled Go chaincodes will be copied to the fabric-baseos runtime image.
    # TWO_DIGIT_VERSION represents Fabric major.minor version.
    runtime: $(DOCKER_NS)/fabric-baseos:$(TWO_DIGIT_VERSION)

    # whether or not golang chaincode should be linked dynamically
    dynamicLink: false

  java:
    # This is an image based on eclipse temurin with addition compiler
    # tools added for java shim layer packaging.
    # This image is packed with shim layer libraries that are necessary
    # for Java chaincode runtime.
    runtime: $(DOCKER_NS)/fabric-javaenv:2.5

  node:
    # This is an image based on node:$(NODE_VER)-alpine
    runtime: $(DOCKER_NS)/fabric-nodeenv:2.5

  # List of directories to treat as external builders and launchers for
  # chaincode. The external builder detection processing will iterate over the
  # builders in the order specified below.
  # If you don't need to fallback to the default Docker builder, also unconfigure vm.endpoint above.
  # To override this property via env variable use CORE_CHAINCODE_EXTERNALBUILDERS: [{name: x, path: dir1}, {name: y, path: dir2}]
  # The path must be an absolute path.
  externalBuilders:
    - name: ccaas_builder
      path: /opt/hyperledger/ccaas_builder
      propagateEnvironment:
        - CHAINCODE_AS_A_SERVICE_BUILDER_CONFIG

  # The maximum duration to wait for the chaincode build and install process
  # to complete.
  installTimeout: 300s

  # Timeout duration for starting up a container and waiting for Register
  # to come through.
  startuptimeout: 300s

  # Timeout duration for Invoke and Init calls to prevent runaway.
  # This timeout is used by all chaincodes in all the channels, including
  # system chaincodes.
  # Note that during Invoke, if the image is not available (e.g. being
  # cleaned up when in development environment), the peer will automatically
  # build the image, which might take more time. In production environment,
  # the chaincode image is unlikely to be deleted, so the timeout could be
  # reduced accordingly.
  executetimeout: 30s

  # There are 2 modes: "dev" and "net".
  # In dev mode, user runs the chaincode after starting peer from
  # command line on local machine.
  # In net mode, peer will run chaincode in a docker container.
  mode: net

  # keepalive in seconds. In situations where the communication goes through a
  # proxy that does not support keep-alive, this parameter will maintain connection
  # between peer and chaincode.
  # A value <= 0 turns keepalive off
  keepalive: 0

  # enabled system chaincodes
  system:
    _lifecycle: enable
    cscc: enable
    lscc: enable
    qscc: enable

  # Logging section for the chaincode container
  logging:
    # Default level for all loggers within the chaincode container
    level: info
    # Override default level for the 'shim' logger
    shim: warning
    # Format for the chaincode container logs
    format: "%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -> %{level:.4s} %{id:03x}%{color:reset} %{message}"

    # RuntimeParams section for parameters that are passed to chaincode
    # to specify additional operation modes in which the peer operates.
  runtimeParams:
    # UseWriteBatch an indication that the peer can accept changes from chaincode in batches
    useWriteBatch: true
    # MaxSizeWriteBatch maximum batch size for the change segment
    maxSizeWriteBatch: 1000
    # UseGetMultipleKeys an indication that the peer can handle get multiple keys
    useGetMultipleKeys: true
    # MaxSizeGetMultipleKeys maximum size of batches with get multiple keys
    maxSizeGetMultipleKeys: 1000

###############################################################################
#
#    Ledger section - ledger configuration encompasses both the blockchain
#    and the state
#
###############################################################################
ledger:
  blockchain:

  state:
    # stateDatabase - options are "goleveldb", "CouchDB"
    # goleveldb - default state database stored in goleveldb.
    # CouchDB - store state database in CouchDB
    stateDatabase: goleveldb
    # Limit on the number of records to return per query
    totalQueryLimit: 100000
    couchDBConfig:
      # It is recommended to run CouchDB on the same server as the peer, and
      # not map the CouchDB container port to a server port in docker-compose.
      # Otherwise proper security must be provided on the connection between
      # CouchDB client (on the peer) and server.
      couchDBAddress: 127.0.0.1:5984
      # This username must have read and write authority on CouchDB
      username:
      # The password is recommended to pass as an environment variable
      # during start up (eg CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD).
      # If it is stored here, the file must be access control protected
      # to prevent unintended users from discovering the password.
      password:
      # Number of retries for CouchDB errors
      maxRetries: 3
      # Number of retries for CouchDB errors during peer startup.
      # The delay between retries doubles for each attempt.
      # Default of 10 retries results in 11 attempts over 2 minutes.
      maxRetriesOnStartup: 10
      # CouchDB request timeout (unit: duration, e.g. 20s)
      requestTimeout: 35s
      # Limit on the number of records per each CouchDB query
      # Note that chaincode queries are only bound by totalQueryLimit.
      # Internally the chaincode may execute multiple CouchDB queries,
      # each of size internalQueryLimit.
      internalQueryLimit: 1000
      # Limit on the number of records per CouchDB bulk update batch
      maxBatchUpdateSize: 1000
      # Create the _global_changes system database
      # This is optional.  Creating the global changes database will require
      # additional system resources to track changes and maintain the database
      createGlobalChangesDB: false
      # CacheSize denotes the maximum mega bytes (MB) to be allocated for the in-memory state
      # cache. Note that CacheSize needs to be a multiple of 32 MB. If it is not a multiple
      # of 32 MB, the peer would round the size to the next multiple of 32 MB.
      # To disable the cache, 0 MB needs to be assigned to the cacheSize.
      cacheSize: 64

  history:
    # enableHistoryDatabase - options are true or false
    # Indicates if the history of key updates should be stored.
    # All history 'index' will be stored in goleveldb, regardless if using
    # CouchDB or alternate database for the state.
    enableHistoryDatabase: true

  pvtdataStore:
    # the maximum db batch size for converting
    # the ineligible missing data entries to eligible missing data entries
    collElgProcMaxDbBatchSize: 5000
    # the minimum duration (in milliseconds) between writing
    # two consecutive db batches for converting the ineligible missing data entries to eligible missing data entries
    collElgProcDbBatchesInterval: 1000
    # The missing data entries are classified into two categories:
    # (1) prioritized
    # (2) deprioritized
    # Initially, all missing data are in the prioritized list. When the
    # reconciler is unable to fetch the missing data from other peers,
    # the unreconciled missing data would be moved to the deprioritized list.
    # The reconciler would retry deprioritized missing data after every
    # deprioritizedDataReconcilerInterval (unit: minutes). Note that the
    # interval needs to be greater than the reconcileSleepInterval
    deprioritizedDataReconcilerInterval: 60m
    # The frequency to purge private data (in number of blocks).
    # Private data is purged from the peer's private data store based on
    # the collection property blockToLive or an explicit chaincode call to PurgePrivateData().
    purgeInterval: 100
    # Whether to log private data keys purged from private data store (INFO level) when explicitly purged via chaincode
    purgedKeyAuditLogging: true

  snapshots:
    # Path on the file system where peer will store ledger snapshots
    # The path must be an absolute path.
    rootDir: /var/hyperledger/production/snapshots

###############################################################################
#
#    Operations section
#
###############################################################################
operations:
  # host and port for the operations server
  listenAddress: 127.0.0.1:9443

  # TLS configuration for the operations endpoint
  tls:
    # TLS enabled
    enabled: false

    # path to PEM encoded server certificate for the operations server
    # The paths in this section may be relative to FABRIC_CFG_PATH or an absolute path.
    cert:
      file:

    # path to PEM encoded server key for the operations server
    key:
      file:

    # most operations service endpoints require client authentication when TLS
    # is enabled. clientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    clientAuthRequired: false

    # paths to PEM encoded ca certificates to trust for client authentication
    clientRootCAs:
      files: []

###############################################################################
#
#    Metrics section
#
###############################################################################
metrics:
  # metrics provider is one of statsd, prometheus, or disabled
  provider: disabled

  # statsd configuration
  statsd:
    # network type: tcp or udp
    network: udp

    # statsd server address
    address: 127.0.0.1:8125

    # the interval at which locally cached counters and gauges are pushed
    # to statsd; timings are pushed immediately
    writeInterval: 10s

    # prefix is prepended to all emitted statsd metrics
    prefix:



./config/network.yaml
----------------------------------------
network:
  name: "my-fabric-network"
  domain: "example.com"
  version: "3.1.1"

organizations:
  - name: "Org1"
    msp_id: "Org1MSP"
    peers:
      - name: "peer0"
        port: 7051
        chaincode_port: 7052
      - name: "peer1"
        port: 8051
        chaincode_port: 8052
    ca:
      port: 7054

  - name: "Org2"
    msp_id: "Org2MSP"
    peers:
      - name: "peer0"
        port: 9051
        chaincode_port: 9052
    ca:
      port: 8054

orderer:
  type: "etcdraft"
  nodes:
    - name: "orderer0"
      port: 7050
      admin_port: 7053

channels:
  - name: "mychannel"
    participating_orgs: ["Org1", "Org2"]

chaincodes:
  - name: "basic_asset"
    version: "1.0"
    pdc: # Defini√ß√£o de Private Data Collections
      - name: "collectionMarbles"
        policy: "OR('Org1MSP.member', 'Org2MSP.member')"
        required_peer_count: 1
        max_peer_count: 2
        block_to_live: 1000


./config/versions.yaml
----------------------------------------
# Defini√ß√µes de Vers√£o para o Ambiente Hyperledger Fabric
versions:
  fabric: "3.1.1"           # Vers√£o dos bin√°rios e imagens peer/orderer
  fabric_ca: "1.5.13"       # Vers√£o da CA (geralmente tem versionamento pr√≥prio)
  go: "1.22.0"              # Fabric 3.x requer Go 1.22+
  docker: "20.10"           # Vers√£o m√≠nima do Docker
  docker_compose: "2.20"    # Vers√£o m√≠nima do Docker Compose (V2)

# Configura√ß√µes globais de imagem
images:
  org_hyperledger: "hyperledger" # Prefixo da imagem docker


./config/orderer.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

---
################################################################################
#
#   Orderer Configuration
#
#   - This controls the type and configuration of the orderer.
#
################################################################################
General:
  # Listen address: The IP on which to bind to listen.
  ListenAddress: 127.0.0.1

  # Listen port: The port on which to bind to listen.
  ListenPort: 7050

  # TLS: TLS settings for the GRPC server.
  TLS:
    # Require server-side TLS
    Enabled: false
    # PrivateKey governs the file location of the private key of the TLS certificate.
    PrivateKey: tls/server.key
    # Certificate governs the file location of the server TLS certificate.
    Certificate: tls/server.crt
    # RootCAs contains a list of additional root certificates used for verifying certificates
    # of other orderer nodes during outbound connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    RootCAs:
      - tls/ca.crt
    # Require client certificates / mutual TLS for inbound connections.
    ClientAuthRequired: false
    # If mutual TLS is enabled, ClientRootCAs contains a list of additional root certificates
    # used for verifying certificates of client connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    ClientRootCAs:
  # Keepalive settings for the GRPC server.
  Keepalive:
    # ServerMinInterval is the minimum permitted time between client pings.
    # If clients send pings more frequently, the server will
    # disconnect them.
    ServerMinInterval: 60s
    # ServerInterval is the time between pings to clients.
    ServerInterval: 7200s
    # ServerTimeout is the duration the server waits for a response from
    # a client before closing the connection.
    ServerTimeout: 20s
  # Config defines the configuration options for backoff GRPC client.
  Backoff:
    # BaseDelay is the amount of time to backoff after the first failure.
    BaseDelay: 1s
    # Multiplier is the factor with which to multiply backoffs after a
    # failed retry. Should ideally be greater than 1.
    Multiplier: 1.6
    # MaxDelay is the upper bound of backoff delay.
    MaxDelay: 2m

  # Since all nodes should be consistent it is recommended to keep
  # the default value of 100MB for MaxRecvMsgSize & MaxSendMsgSize
  # Max message size in bytes the GRPC server and client can receive
  MaxRecvMsgSize: 104857600
  # Max message size in bytes the GRPC server and client can send
  MaxSendMsgSize: 104857600
  # Throttling prevents clients from sending too many transactions
  # per second to the broadcast API of this node.
  # It is only enforced when the Rate is non-zero, and when the client
  # connects using mutual TLS.
  # The effective rate of transactions is divided across all clients
  # and organizations at a given unit of time governed by the inactivity timeout.
  # When a client's rate of transaction submission exhausts its allocated budget,
  # it is throttled until additional "budget" is allocated (it is allocated once per second).
  Throttling:
    # Rate is the maximum rate (transactions per second) for all clients combined.
    # A zero rate disables throttling.
    Rate: 0
    # InactivityTimeout defines the time frame after which
    # inactive clients are pruned from memory and are not considered
    # when allocating the budget for throttling per client.
    InactivityTimeout: 5s

  # Cluster settings for ordering service nodes that communicate with other ordering service nodes
  # such as Raft based ordering service.
  Cluster:
    # SendBufferSize is the maximum number of messages in the egress buffer.
    # Consensus messages are dropped if the buffer is full, and transaction
    # messages are waiting for space to be freed.
    SendBufferSize: 100

    # ClientCertificate governs the file location of the client TLS certificate
    # used to establish mutual TLS connections with other ordering service nodes.
    # If not set, the server General.TLS.Certificate is re-used.
    ClientCertificate:
    # ClientPrivateKey governs the file location of the private key of the client TLS certificate.
    # If not set, the server General.TLS.PrivateKey is re-used.
    ClientPrivateKey:

    # The below 4 properties should be either set together, or be unset together.
    # If they are set, then the orderer node uses a separate listener for intra-cluster
    # communication. If they are unset, then the general orderer listener is used.
    # This is useful if you want to use a different TLS server certificates on the
    # client-facing and the intra-cluster listeners.

    # ListenPort defines the port on which the cluster listens to connections.
    ListenPort:
    # ListenAddress defines the IP on which to listen to intra-cluster communication.
    ListenAddress:
    # ServerCertificate defines the file location of the server TLS certificate used for intra-cluster
    # communication.
    ServerCertificate:
    # ServerPrivateKey defines the file location of the private key of the TLS certificate.
    ServerPrivateKey:

    # ReplicationPolicy defines how blocks are replicated between orderers.
    # Permitted values:
    # in BFT: "simple" | "consensus" (default);
    # in etcdraft: ignored, (always "simple", regardless of value in config).
    # When running a Raft orderer or with ReplicationPolicy set to 'simple', an orderer
    # replicates blocks from a single orderer node.
    # When running a BFT orderer with ReplicationPolicy set to 'consensus', the orderer
    # replicates blocks from a single orderer node, but replicates block headers with signatures
    # from other orderer nodes, and if it suspects the former node withholds blocks from it,
    # it switches to a new orderer as a source of blocks.
    ReplicationPolicy:

  # LocalMSPDir is where to find the private crypto material needed by the
  # orderer. It is set relative here as a default for dev environments but
  # should be changed to the real location in production.
  LocalMSPDir: msp

  # LocalMSPID is the identity to register the local MSP material with the MSP
  # manager. The sample organization defined in the
  # sample configuration provided has an MSP ID of "SampleOrg".
  LocalMSPID: SampleOrg

  # Enable an HTTP service for Go "pprof" profiling as documented at:
  # https://golang.org/pkg/net/http/pprof
  Profile:
    Enabled: false
    Address: 0.0.0.0:6060

  # BCCSP configures the blockchain crypto service providers.
  BCCSP:
    # Default specifies the preferred blockchain crypto service provider
    # to use. If the preferred provider is not available, the software
    # based provider ("SW") will be used.
    # Valid providers are:
    #  - SW: a software based crypto provider
    #  - PKCS11: a CA hardware security module crypto provider.
    Default: SW

    # SW configures the software based blockchain crypto provider.
    SW:
      # TODO: The default Hash and Security level needs refactoring to be
      # fully configurable. Changing these defaults requires coordination
      # SHA2 is hardcoded in several places, not only BCCSP
      Hash: SHA2
      Security: 256
      # Location of key store. If this is unset, a location will be
      # chosen using: 'LocalMSPDir'/keystore
      FileKeyStore:
        KeyStore:

    # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)
    PKCS11:
      # Location of the PKCS11 module library
      Library:
      # Token Label
      Label:
      # User PIN
      Pin:
      Hash:
      Security:
      FileKeyStore:
        KeyStore:

  # Authentication contains configuration parameters related to authenticating
  # client messages
  Authentication:
    # the acceptable difference between the current server time and the
    # client's time as specified in a client request message
    TimeWindow: 15m

################################################################################
#
#   SECTION: File Ledger
#
#   - This section applies to the configuration of the file ledger.
#
################################################################################
FileLedger:
  # Location: The directory to store the blocks in.
  Location: /var/hyperledger/production/orderer

################################################################################
#
#   Debug Configuration
#
#   - This controls the debugging options for the orderer
#
################################################################################
Debug:
  # BroadcastTraceDir when set will cause each request to the Broadcast service
  # for this orderer to be written to a file in this directory
  BroadcastTraceDir:

  # DeliverTraceDir when set will cause each request to the Deliver service
  # for this orderer to be written to a file in this directory
  DeliverTraceDir:

################################################################################
#
#   Operations Configuration
#
#   - This configures the operations server endpoint for the orderer
#
################################################################################
Operations:
  # host and port for the operations server
  ListenAddress: 127.0.0.1:8443

  # TLS configuration for the operations endpoint
  TLS:
    # TLS enabled
    Enabled: false

    # Certificate is the location of the PEM encoded TLS certificate
    Certificate:

    # PrivateKey points to the location of the PEM-encoded key
    PrivateKey:

    # Most operations service endpoints require client authentication when TLS
    # is enabled. ClientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    ClientAuthRequired: false

    # Paths to PEM encoded ca certificates to trust for client authentication
    ClientRootCAs: []

################################################################################
#
#   Metrics Configuration
#
#   - This configures metrics collection for the orderer
#
################################################################################
Metrics:
  # The metrics provider is one of statsd, prometheus, or disabled
  Provider: disabled

  # The statsd configuration
  Statsd:
    # network type: tcp or udp
    Network: udp

    # the statsd server address
    Address: 127.0.0.1:8125

    # The interval at which locally cached counters and gauges are pushed
    # to statsd; timings are pushed immediately
    WriteInterval: 30s

    # The prefix is prepended to all emitted statsd metrics
    Prefix:

################################################################################
#
#   Admin Configuration
#
#   - This configures the admin server endpoint for the orderer
#
################################################################################
Admin:
  # host and port for the admin server
  ListenAddress: 127.0.0.1:9443

  # TLS configuration for the admin endpoint
  TLS:
    # TLS enabled
    Enabled: false

    # Certificate is the location of the PEM encoded TLS certificate
    Certificate:

    # PrivateKey points to the location of the PEM-encoded key
    PrivateKey:

    # Most admin service endpoints require client authentication when TLS
    # is enabled. ClientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    #
    # NOTE: When TLS is enabled, the admin endpoint requires mutual TLS. The
    # orderer will panic on startup if this value is set to false.
    ClientAuthRequired: true

    # Paths to PEM encoded ca certificates to trust for client authentication
    ClientRootCAs: []

################################################################################
#
#   Channel participation API Configuration
#
#   - This provides the channel participation API configuration for the orderer.
#   - Channel participation uses the ListenAddress and TLS settings of the Admin
#     service.
#
################################################################################
ChannelParticipation:
  # Channel participation API is enabled. Deprecated: must be set to true.
  Enabled: true

  # The maximum size of the request body when joining a channel.
  MaxRequestBodySize: 1 MB

################################################################################
#
#   Consensus Configuration
#
#   - This section contains config options for a consensus plugin. It is opaque
#     to orderer, and completely up to consensus implementation to make use of.
#
################################################################################
Consensus:
  # The allowed key-value pairs here depend on consensus plugin. For etcd/raft,
  # we use following options:

  # WALDir specifies the location at which Write Ahead Logs for etcd/raft are
  # stored. Each channel will have its own subdir named after channel ID.
  WALDir: /var/hyperledger/production/orderer/etcdraft/wal

  # SnapDir specifies the location at which snapshots for etcd/raft are
  # stored. Each channel will have its own subdir named after channel ID.
  SnapDir: /var/hyperledger/production/orderer/etcdraft/snapshot



./scripts/check_reqs.sh
----------------------------------------
#!/bin/bash

# Define o diret√≥rio raiz do projeto (assumindo que estamos rodando via Python ou da pasta scripts)
# Se NETWORK_DIR vier do Python, usamos o pai dele como raiz, ou o diret√≥rio atual
PROJECT_ROOT=${NETWORK_DIR%/network} # Remove '/network' do final para pegar a raiz
if [ -z "$PROJECT_ROOT" ]; then
    PROJECT_ROOT="."
fi

# Adiciona ./bin local ao PATH temporariamente para verifica√ß√£o
export PATH=$PROJECT_ROOT/bin:$PATH

echo "üîç Verificando pr√©-requisitos para Fabric $FABRIC_VERSION e CA $CA_VERSION..."

# ---------------------------------------------------------
# 1. Verificar Docker
# ---------------------------------------------------------
if ! command -v docker &> /dev/null; then
    echo "‚ùå Docker n√£o encontrado! Instale o Docker Desktop ou Engine."
    exit 1
fi
DOCKER_V=$(docker --version)
echo "‚úÖ Docker encontrado: $DOCKER_V"

# ---------------------------------------------------------
# 2. Verificar Go (Opcional, mas recomendado verificar)
# ---------------------------------------------------------
if command -v go &> /dev/null; then
    CURRENT_GO=$(go version | awk '{print $3}' | sed 's/go//')
    # Compara√ß√£o lexicogr√°fica simples
    if [[ "$CURRENT_GO" < "$GO_VERSION" ]]; then
        echo "‚ö†Ô∏è  AVISO: Vers√£o do Go ($CURRENT_GO) √© menor que a recomendada ($GO_VERSION)"
    else
        echo "‚úÖ Go vers√£o $CURRENT_GO compat√≠vel."
    fi
else
    echo "‚ö†Ô∏è  Go n√£o instalado (Isso √© OK se voc√™ n√£o for compilar Chaincode em Go localmente)"
fi

# ---------------------------------------------------------
# 3. Verificar e Baixar Bin√°rios do Fabric
# ---------------------------------------------------------
NEED_INSTALL=false

if command -v peer &> /dev/null; then
    FABRIC_BIN_VER=$(configtxgen -version | grep "Version:" | awk '{print $2}')
    
    if [[ "$FABRIC_BIN_VER" != "$FABRIC_VERSION" ]]; then
        echo "‚ö†Ô∏è  Vers√£o local ($FABRIC_BIN_VER) difere da desejada ($FABRIC_VERSION)."
        NEED_INSTALL=true
    else
        echo "‚úÖ Bin√°rios do Fabric ($FABRIC_BIN_VER) j√° instalados corretamente."
    fi
else
    echo "‚ÑπÔ∏è  Bin√°rios do Fabric n√£o encontrados no PATH."
    NEED_INSTALL=true
fi

if [ "$NEED_INSTALL" = true ]; then
    echo "‚¨áÔ∏è  Iniciando download dos bin√°rios do Fabric $FABRIC_VERSION..."
    
    # Entra na raiz do projeto para criar a pasta /bin l√°
    pushd "$PROJECT_ROOT" > /dev/null

    # Baixa o script oficial de instala√ß√£o
    curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh -o install-fabric.sh
    chmod +x install-fabric.sh

    # Executa a instala√ß√£o:
    # binary: baixa apenas os bin√°rios (peer, orderer, configtxgen, etc)
    # docker: baixa as imagens docker (opcional, mas recomendado para garantir vers√µes)
    # --fabric-version: vers√£o definida no python
    # --ca-version: vers√£o da CA definida no python
    ./install-fabric.sh --fabric-version $FABRIC_VERSION --ca-version $CA_VERSION binary docker

    # Remove o script de instala√ß√£o para limpar
    rm install-fabric.sh
    
    popd > /dev/null

    echo "‚úÖ Download e instala√ß√£o conclu√≠dos na pasta bin/ local."

    export PATH="$PATH:$PWD/../bin"
fi

echo "--- Verifica√ß√£o e Configura√ß√£o Conclu√≠da ---"


./main.py
----------------------------------------
from src.path_manager import PathManager
from src.config_loader import ConfigLoader
from src.network_controller import NetworkController

def main():
    # 1. Configurar Caminhos
    paths = PathManager()

    # 2. Carregar Configura√ß√µes
    loader = ConfigLoader(paths.network_yaml, paths.versions_yaml)
    config = loader.load()

    # 3. Inicializar Controlador
    controller = NetworkController(config, paths)

    # 4. Verifica vers√µes e pr√©-requisitos
    try:
        controller._run_script("check_reqs.sh")
    except Exception as e:
        print(f"\nüíÄ Erro nos pr√©-requisitos: {e}")
        return

    
    # # 5. Execu√ß√£o Passo a Passo
    # try:
    #     controller.prepare_environment()
    #     controller.generate_crypto_material()
    #     # controller.generate_docker_compose()
    #     # controller.start_network()
        
    # except Exception as e:
    #     print(f"\nüíÄ Erro fatal: {e}")

if __name__ == "__main__":
    main()


./src/path_manager.py
----------------------------------------
import os
from pathlib import Path

class PathManager:
    def __init__(self):
        # Base do projeto (assumindo que este arquivo est√° em src/)
        self.base_dir = Path(__file__).parent.parent.resolve()
        
        # Caminhos principais
        self.config_dir = self.base_dir / "config"
        self.network_dir = self.base_dir / "network"
        self.scripts_dir = self.base_dir / "scripts"
        self.templates_dir = self.base_dir / "template"
        self.versions_yaml = self.config_dir / "versions.yaml"
        
        # Arquivo de config
        self.network_yaml = self.config_dir / "network.yaml"

    def get_paths(self):
        """Retorna um dicion√°rio com todos os caminhos convertidos para string"""
        return {
            "BASE_DIR": str(self.base_dir),
            "NETWORK_DIR": str(self.network_dir),
            "SCRIPTS_DIR": str(self.scripts_dir),
            "CONFIG_FILE": str(self.network_yaml),
            "TEMPLATES_DIR": str(self.templates_dir),
        }

    def ensure_network_dirs(self):
        """Cria a estrutura de pastas dentro de network/ se n√£o existir"""
        subdirs = ["organizations", "channel-artifacts", "docker"]
        for sub in subdirs:
            (self.network_dir / sub).mkdir(parents=True, exist_ok=True)


./src/colors.py
----------------------------------------
class Colors:
    RESET = "\033[0m"
    BLUE = "\033[34m"
    GREEN = "\033[32m"
    RED = "\033[31m"
    YELLOW = "\033[33m"

    def infoln(msg: str):
        print(f"{Colors.BLUE}[INFO] {msg}{Colors.RESET}")

    def successln(msg: str):
        print(f"{Colors.GREEN}[SUCESSO] {msg}{Colors.RESET}")

    def errorln(msg: str):
        print(f"{Colors.RED}[ERRO] {msg}{Colors.RESET}")

    def warnln(msg: str):
        print(f"{Colors.YELLOW}[AVISO] {msg}{Colors.RESET}")



./src/config_loader.py
----------------------------------------
# src/config_loader.py (Atualizado)
import yaml
import os
from .colors import Colors as co

class ConfigLoader:
    def __init__(self, network_config_path, versions_config_path):
        self.network_config_path = network_config_path
        self.versions_config_path = versions_config_path
        self.full_config = {}

    def load(self):
        # 1. Carrega topologia da rede
        with open(self.network_config_path, 'r') as f:
            self.full_config['network_topology'] = yaml.safe_load(f)

        # 2. Carrega vers√µes
        if os.path.exists(self.versions_config_path):
            with open(self.versions_config_path, 'r') as f:
                self.full_config['env_versions'] = yaml.safe_load(f)
        else:
            raise FileNotFoundError("Arquivo versions.yaml n√£o encontrado!")

        co.infoln("Todas as configura√ß√µes carregadas.\n")
        return self.full_config


./src/__init__.py
----------------------------------------



./src/network_controller.py
----------------------------------------
import subprocess
import os
from .colors import Colors as co

class NetworkController:
    def __init__(self, config, paths):
        self.config = config
        self.paths = paths # Inst√¢ncia do PathManager

    def _get_env_vars(self):
        """Converte as configura√ß√µes de vers√£o em vari√°veis de ambiente"""
        versions = self.config['env_versions']['versions']
        images = self.config['env_versions']['images']
        
        # Caminho absoluto para a pasta bin do projeto
        project_bin_path = os.path.join(str(self.paths.base_dir), "bin")
        
        # Pega o PATH atual do sistema
        current_path = os.environ["PATH"]

        return {
            "FABRIC_VERSION": versions['fabric'],
            "CA_VERSION": versions['fabric_ca'],
            "GO_VERSION": versions['go'],
            "DOCKER_IMAGE_PREFIX": images['org_hyperledger'],
            "PATH": f"{project_bin_path}:{current_path}"
        }

    def run_script(self, script_name, extra_env=None):
        script_path = os.path.join(self.paths.scripts_dir, script_name)
        
        # 1. Carrega vari√°veis base do sistema
        env = os.environ.copy()
        
        # 2. Injeta vari√°veis de vers√£o (Carregadas do YAML)
        env.update(self._get_env_vars())
        
        # 3. Injeta o caminho da pasta network (Do PathManager)
        env["NETWORK_DIR"] = str(self.paths.network_dir)

        # 4. Injeta vari√°veis extras espec√≠ficas da chamada
        if extra_env:
            env.update(extra_env)

        co.infoln(f"Executando {script_name} (Fabric v{env['FABRIC_VERSION']})...")
        
        subprocess.run(["bash", script_path], check=True, env=env)

    def prepare_environment(self):
        # Cria as pastas necess√°rias
        self.paths.ensure_network_dirs()
        # Poderia chamar um script de limpeza aqui tamb√©m
        # self._run_script("00_cleanup.sh")

    

    


./config/configtx.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

################################################################################
#
#   NOTE
#
#   Since release V3.0 Solo, Kafka and the System Channel have been removed
#   and are no longer supported.
#
################################################################################

---
################################################################################
#
#   ORGANIZATIONS
#
#   This section defines the organizational identities that can be referenced
#   in the configuration profiles.
#
################################################################################
Organizations:
  # SampleOrg defines an MSP using the sampleconfig. It should never be used
  # in production but may be used as a template for other definitions.
  - &SampleOrg
    # Name is the key by which this org will be referenced in channel
    # configuration transactions.
    # Name can include alphanumeric characters as well as dots and dashes.
    Name: SampleOrg

    # SkipAsForeign can be set to true for org definitions which are to be
    # inherited from the orderer system channel during channel creation.  This
    # is especially useful when an admin of a single org without access to the
    # MSP directories of the other orgs wishes to create a channel.  Note
    # this property must always be set to false for orgs included in block
    # creation.
    SkipAsForeign: false

    # ID is the key by which this org's MSP definition will be referenced.
    # ID can include alphanumeric characters as well as dots and dashes.
    ID: SampleOrg

    # MSPDir is the filesystem path which contains the MSP configuration.
    MSPDir: msp

    # Policies defines the set of policies at this level of the config tree
    # For organization policies, their canonical path is usually
    #   /Channel/<Application|Orderer>/<OrgName>/<PolicyName>
    Policies: &SampleOrgPolicies
      Readers:
        Type: Signature
        Rule: "OR('SampleOrg.member')"
        # If your MSP is configured with the new NodeOUs, you might
        # want to use a more specific rule like the following:
        # Rule: "OR('SampleOrg.admin', 'SampleOrg.peer', 'SampleOrg.client')"
      Writers:
        Type: Signature
        Rule: "OR('SampleOrg.member')"
        # If your MSP is configured with the new NodeOUs, you might
        # want to use a more specific rule like the following:
        # Rule: "OR('SampleOrg.admin', 'SampleOrg.client')"
      Admins:
        Type: Signature
        Rule: "OR('SampleOrg.admin')"
      Endorsement:
        Type: Signature
        Rule: "OR('SampleOrg.member')"

    # OrdererEndpoints is a list of all orderers this org runs which clients
    # and peers may to connect to push transactions and receive blocks respectively.
    OrdererEndpoints:
      - "127.0.0.1:7050"

################################################################################
#
#   CAPABILITIES
#
#   This section defines the capabilities of fabric network. This is a new
#   concept as of v1.1.0 and should not be utilized in mixed networks with
#   v1.0.x peers and orderers.  Capabilities define features which must be
#   present in a fabric binary for that binary to safely participate in the
#   fabric network.  For instance, if a new MSP type is added, newer binaries
#   might recognize and validate the signatures from this type, while older
#   binaries without this support would be unable to validate those
#   transactions.  This could lead to different versions of the fabric binaries
#   having different world states.  Instead, defining a capability for a channel
#   informs those binaries without this capability that they must cease
#   processing transactions until they have been upgraded.  For v1.0.x if any
#   capabilities are defined (including a map with all capabilities turned off)
#   then the v1.0.x peer will deliberately crash.
#
################################################################################
Capabilities:
  # Channel capabilities apply to both the orderers and the peers and must be
  # supported by both.
  # Set the value of the capability to true to require it.
  Channel: &ChannelCapabilities
    # V3.0 for Channel is a catchall flag for behavior which has been
    # determined to be desired for all orderers and peers running at the v3.0.0
    # level, but which would be incompatible with orderers and peers from
    # prior releases.
    # Prior to enabling V3.0 channel capabilities, ensure that all
    # orderers and peers on a channel are at v3.0.0 or later.
    V3_0: true

  # Orderer capabilities apply only to the orderers, and may be safely
  # used with prior release peers.
  # Set the value of the capability to true to require it.
  Orderer: &OrdererCapabilities
    # V1.1 for Orderer is a catchall flag for behavior which has been
    # determined to be desired for all orderers running at the v1.1.x
    # level, but which would be incompatible with orderers from prior releases.
    # Prior to enabling V2.0 orderer capabilities, ensure that all
    # orderers on a channel are at v2.0.0 or later.
    V2_0: true

  # Application capabilities apply only to the peer network, and may be safely
  # used with prior release orderers.
  # Set the value of the capability to true to require it.
  Application: &ApplicationCapabilities
    # V2.5 for Application enables the new non-backwards compatible
    # features of fabric v2.5, namely the ability to purge private data.
    # Prior to enabling V2.5 application capabilities, ensure that all
    # peers on a channel are at v2.5.0 or later.
    V2_5: true

################################################################################
#
#   APPLICATION
#
#   This section defines the values to encode into a config transaction or
#   genesis block for application-related parameters.
#
################################################################################
Application: &ApplicationDefaults
  ACLs: &ACLsDefault
    # This section provides defaults for policies for various resources
    # in the system. These "resources" could be functions on system chaincodes
    # (e.g., "GetBlockByNumber" on the "qscc" system chaincode) or other resources
    # (e.g.,who can receive Block events). This section does NOT specify the resource's
    # definition or API, but just the ACL policy for it.
    #
    # Users can override these defaults with their own policy mapping by defining the
    # mapping under ACLs in their channel definition

    #---New Lifecycle System Chaincode (_lifecycle) function to policy mapping for access control--#

    # ACL policy for _lifecycle's "CheckCommitReadiness" function
    _lifecycle/CheckCommitReadiness: /Channel/Application/Writers

    # ACL policy for _lifecycle's "CommitChaincodeDefinition" function
    _lifecycle/CommitChaincodeDefinition: /Channel/Application/Writers

    # ACL policy for _lifecycle's "QueryChaincodeDefinition" function
    _lifecycle/QueryChaincodeDefinition: /Channel/Application/Writers

    # ACL policy for _lifecycle's "QueryChaincodeDefinitions" function
    _lifecycle/QueryChaincodeDefinitions: /Channel/Application/Writers

    #---Lifecycle System Chaincode (lscc) function to policy mapping for access control---#

    # ACL policy for lscc's "getid" function
    lscc/ChaincodeExists: /Channel/Application/Readers

    # ACL policy for lscc's "getdepspec" function
    lscc/GetDeploymentSpec: /Channel/Application/Readers

    # ACL policy for lscc's "getccdata" function
    lscc/GetChaincodeData: /Channel/Application/Readers

    # ACL Policy for lscc's "getchaincodes" function
    lscc/GetInstantiatedChaincodes: /Channel/Application/Readers

    #---Query System Chaincode (qscc) function to policy mapping for access control---#

    # ACL policy for qscc's "GetChainInfo" function
    qscc/GetChainInfo: /Channel/Application/Readers

    # ACL policy for qscc's "GetBlockByNumber" function
    qscc/GetBlockByNumber: /Channel/Application/Readers

    # ACL policy for qscc's  "GetBlockByHash" function
    qscc/GetBlockByHash: /Channel/Application/Readers

    # ACL policy for qscc's "GetTransactionByID" function
    qscc/GetTransactionByID: /Channel/Application/Readers

    # ACL policy for qscc's "GetBlockByTxID" function
    qscc/GetBlockByTxID: /Channel/Application/Readers

    #---Configuration System Chaincode (cscc) function to policy mapping for access control---#

    # ACL policy for cscc's "GetConfigBlock" function
    cscc/GetConfigBlock: /Channel/Application/Readers

    # ACL policy for cscc's "GetChannelConfig" function
    cscc/GetChannelConfig: /Channel/Application/Readers

    #---Miscellaneous peer function to policy mapping for access control---#

    # ACL policy for invoking chaincodes on peer
    peer/Propose: /Channel/Application/Writers

    # ACL policy for chaincode to chaincode invocation
    peer/ChaincodeToChaincode: /Channel/Application/Writers

    #---Events resource to policy mapping for access control###---#

    # ACL policy for sending block events
    event/Block: /Channel/Application/Readers

    # ACL policy for sending filtered block events
    event/FilteredBlock: /Channel/Application/Readers

  # Organizations lists the orgs participating on the application side of the
  # network.
  Organizations:

  # Policies defines the set of policies at this level of the config tree
  # For Application policies, their canonical path is
  #   /Channel/Application/<PolicyName>
  Policies: &ApplicationDefaultPolicies
    LifecycleEndorsement:
      Type: ImplicitMeta
      Rule: "MAJORITY Endorsement"
    Endorsement:
      Type: ImplicitMeta
      Rule: "MAJORITY Endorsement"
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"

  # Capabilities describes the application level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *ApplicationCapabilities

################################################################################
#
#   ORDERER
#
#   This section defines the values to encode into a config transaction or
#   genesis block for orderer related parameters.
#
################################################################################
Orderer: &OrdererDefaults
  # Orderer Type: The orderer implementation to start.
  # Available types are "etcdraft" and "BFT".
  # Please note that "solo" and "kafka" are no longer supported.
  OrdererType: etcdraft

  # Addresses used to be the list of orderer addresses that clients and peers
  # could connect to.  However, this does not allow clients to associate orderer
  # addresses and orderer organizations which can be useful for things such
  # as TLS validation.  The preferred way to specify orderer addresses is now
  # to include the OrdererEndpoints item in your org definition
  Addresses:
    # - 127.0.0.1:7050

  # Batch Timeout: The amount of time to wait before creating a batch.
  BatchTimeout: 2s

  # Batch Size: Controls the number of messages batched into a block.
  # The orderer views messages opaquely, but typically, messages may
  # be considered to be Fabric transactions.  The 'batch' is the group
  # of messages in the 'data' field of the block.  Blocks will be a few kb
  # larger than the batch size, when signatures, hashes, and other metadata
  # is applied.
  BatchSize:
    # Max Message Count: The maximum number of messages to permit in a
    # batch.  No block will contain more than this number of messages.
    MaxMessageCount: 500

    # Absolute Max Bytes: The absolute maximum number of bytes allowed for
    # the serialized messages in a batch. The maximum block size is this value
    # plus the size of the associated metadata (usually a few KB depending
    # upon the size of the signing identities). Any transaction larger than
    # this value will be rejected by ordering.
    # It is recommended not to exceed 49 MB, given the default grpc max message size of 100 MB
    # configured on orderer and peer nodes (and allowing for message expansion during communication).
    AbsoluteMaxBytes: 10 MB

    # Preferred Max Bytes: The preferred maximum number of bytes allowed
    # for the serialized messages in a batch. Roughly, this field may be considered
    # the best effort maximum size of a batch. A batch will fill with messages
    # until this size is reached (or the max message count, or batch timeout is
    # exceeded).  If adding a new message to the batch would cause the batch to
    # exceed the preferred max bytes, then the current batch is closed and written
    # to a block, and a new batch containing the new message is created.  If a
    # message larger than the preferred max bytes is received, then its batch
    # will contain only that message.  Because messages may be larger than
    # preferred max bytes (up to AbsoluteMaxBytes), some batches may exceed
    # the preferred max bytes, but will always contain exactly one transaction.
    PreferredMaxBytes: 2 MB

  # Max Channels is the maximum number of channels to allow on the ordering
  # network. When set to 0, this implies no maximum number of channels.
  MaxChannels: 0

  # ConsenterMapping contains the definition of consenter identity, endpoints, and crypto material.
  # The ConsenterMapping is used in the BFT consensus protocol, and should include enough servers to ensure
  # fault-tolerance; In BFT this number is at least 3*F+1, where F is the number of potential failures.
  # In BFT it is highly recommended that the addresses for delivery & broadcast (the OrdererEndpoints item in the
  # org definition) map 1:1 to the Orderer/ConsenterMapping (for cluster consensus). That is, every consenter should
  # be represented by a delivery endpoint. Note that in BFT (V3) global Orderer/Addresses are no longer supported.
  ConsenterMapping:
    - ID: 1
      Host: bft0.example.com
      Port: 7050
      MSPID: OrdererOrg1
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert0
      ServerTLSCert: path/to/ServerTLSCert0
    - ID: 2
      Host: bft1.example.com
      Port: 7050
      MSPID: OrdererOrg2
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert1
      ServerTLSCert: path/to/ServerTLSCert1
    - ID: 3
      Host: bft2.example.com
      Port: 7050
      MSPID: OrdererOrg3
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert2
      ServerTLSCert: path/to/ServerTLSCert2
    - ID: 4
      Host: bft3.example.com
      Port: 7050
      MSPID: OrdererOrg4
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert3
      ServerTLSCert: path/to/ServerTLSCert3

  # EtcdRaft defines configuration which must be set when the "etcdraft"
  # orderertype is chosen.
  EtcdRaft:
    # The set of Raft replicas for this network. For the etcd/raft-based
    # implementation, we expect every replica to also be an OSN. Therefore,
    # a subset of the host:port items enumerated in this list should be
    # replicated under the Orderer.Addresses key above.
    Consenters:
      - Host: raft0.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert0
        ServerTLSCert: path/to/ServerTLSCert0
      - Host: raft1.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert1
        ServerTLSCert: path/to/ServerTLSCert1
      - Host: raft2.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert2
        ServerTLSCert: path/to/ServerTLSCert2

    # Options to be specified for all the etcd/raft nodes. The values here
    # are the defaults for all new channels and can be modified on a
    # per-channel basis via configuration updates.
    Options:
      # TickInterval is the time interval between two Node.Tick invocations.
      TickInterval: 500ms

      # ElectionTick is the number of Node.Tick invocations that must pass
      # between elections. That is, if a follower does not receive any
      # message from the leader of current term before ElectionTick has
      # elapsed, it will become candidate and start an election.
      # ElectionTick must be greater than HeartbeatTick.
      ElectionTick: 10

      # HeartbeatTick is the number of Node.Tick invocations that must
      # pass between heartbeats. That is, a leader sends heartbeat
      # messages to maintain its leadership every HeartbeatTick ticks.
      HeartbeatTick: 1

      # MaxInflightBlocks limits the max number of in-flight append messages
      # during optimistic replication phase.
      MaxInflightBlocks: 5

      # SnapshotIntervalSize defines number of bytes per which a snapshot is taken
      SnapshotIntervalSize: 16 MB

  # Organizations lists the orgs participating on the orderer side of the
  # network.
  Organizations:

  # Policies defines the set of policies at this level of the config tree
  # For Orderer policies, their canonical path is
  #   /Channel/Orderer/<PolicyName>
  Policies:
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"
    # BlockValidation specifies what signatures must be included in the block
    # from the orderer for the peer to validate it.
    BlockValidation:
      Type: ImplicitMeta
      Rule: "ANY Writers"

  # Capabilities describes the orderer level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *OrdererCapabilities

################################################################################
#
#   CHANNEL
#
#   This section defines the values to encode into a config transaction or
#   genesis block for channel related parameters.
#
################################################################################
Channel: &ChannelDefaults
  # Policies defines the set of policies at this level of the config tree
  # For Channel policies, their canonical path is
  #   /Channel/<PolicyName>
  Policies:
    # Who may invoke the 'Deliver' API
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    # Who may invoke the 'Broadcast' API
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    # By default, who may modify elements at this config level
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"

  # Capabilities describes the channel level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *ChannelCapabilities

################################################################################
#
#   PROFILES
#
#   Different configuration profiles may be encoded here to be specified as
#   parameters to the configtxgen tool. The profiles which specify consortiums
#   are to be used for generating the orderer genesis block. With the correct
#   consortium members defined in the orderer genesis block, channel creation
#   requests may be generated with only the org member names and a consortium
#   name.
#
################################################################################
Profiles:
  # SampleSingleMSPSolo defines a configuration which uses the Solo orderer,
  # and contains a single MSP definition (the MSP sampleconfig).
  # The Consortium SampleConsortium has only a single member, SampleOrg.
  SampleSingleMSPSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
      Organizations:
        - *SampleOrg
    Consortiums:
      SampleConsortium:
        Organizations:
          - *SampleOrg

  # SampleInsecureSolo defines a configuration which uses the Solo orderer,
  # contains no MSP definitions, and allows all transactions and channel
  # creation requests for the consortium SampleConsortium.
  SampleInsecureSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
    Consortiums:
      SampleConsortium:
        Organizations:

  # SampleDevModeSolo defines a configuration which uses the Solo orderer,
  # contains the sample MSP as both orderer and consortium member, and
  # requires only basic membership for admin privileges. It also defines
  # an Application on the ordering system channel, which should usually
  # be avoided.
  SampleDevModeSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Consortiums:
      SampleConsortium:
        Organizations:
          - <<: *SampleOrg
            Policies:
              <<: *SampleOrgPolicies
              Admins:
                Type: Signature
                Rule: "OR('SampleOrg.member')"


  # SampleSingleMSPChannel defines a channel with only the sample org as a
  # member. It is designed to be used in conjunction with SampleSingleMSPSolo
  # orderer profile. Note, for channel creation profiles, only the
  # 'Application' section and consortium # name are considered.
  SampleSingleMSPChannel:
    <<: *ChannelDefaults
    Consortium: SampleConsortium
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg

  # SampleDevModeEtcdRaft defines a configuration that differs from the
  # SampleDevModeSolo one only in that it uses the etcd/raft-based orderer.
  SampleDevModeEtcdRaft:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Consortiums:
      SampleConsortium:
        Organizations:
          - <<: *SampleOrg
            Policies:
              <<: *SampleOrgPolicies
              Admins:
                Type: Signature
                Rule: "OR('SampleOrg.member')"

  # SampleAppChannelInsecureSolo defines an application channel configuration
  # which uses the Solo orderer and contains no MSP definitions.
  SampleAppChannelInsecureSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
    Application:
      <<: *ApplicationDefaults

  # SampleAppChannelEtcdRaft defines an application channel configuration
  # that uses the etcd/raft-based orderer.
  SampleAppChannelEtcdRaft:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
          OrdererEndpoints:
            - "127.0.0.1:7050"
            - "127.0.0.1:7051"
            - "127.0.0.1:7052"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"

  # SampleAppChannelSmartBft defines an application channel configuration
  # that uses the Smart BFT orderer.
  SampleAppChannelSmartBft:
    <<: *ChannelDefaults
    Consortium: SampleConsortium
    Orderer:
      <<: *OrdererDefaults
      OrdererType: BFT
      BatchSize:
        MaxMessageCount: 5000
        AbsoluteMaxBytes: 10 MB
      SmartBFT:
        RequestBatchMaxInterval: 200ms
        RequestForwardTimeout: 5s
        RequestComplainTimeout: 20s
        RequestAutoRemoveTimeout: 3m0s
        ViewChangeResendInterval: 5s
        ViewChangeTimeout: 20s
        LeaderHeartbeatTimeout: 1m0s
        CollectTimeout: 1s
        IncomingMessageBufferSize: 200
        RequestPoolSize: 100000
        LeaderHeartbeatCount: 10
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"



./config/core.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

###############################################################################
#
#    Peer section
#
###############################################################################
peer:
  # The peer id provides a name for this peer instance and is used when
  # naming docker resources.
  id: jdoe

  # The networkId allows for logical separation of networks and is used when
  # naming docker resources.
  networkId: dev

  # The Address at local network interface this Peer will listen on.
  # By default, it will listen on all network interfaces
  listenAddress: 0.0.0.0:7051

  # The endpoint this peer uses to listen for inbound chaincode connections.
  # If this is commented-out, the listen address is selected to be
  # the peer's address (see below) with port 7052
  # chaincodeListenAddress: 0.0.0.0:7052

  # The endpoint the chaincode for this peer uses to connect to the peer.
  # If this is not specified, the chaincodeListenAddress address is selected.
  # And if chaincodeListenAddress is not specified, address is selected from
  # peer address (see below). If specified peer address is invalid then it
  # will fallback to the auto detected IP (local IP) regardless of the peer
  # addressAutoDetect value.
  # chaincodeAddress: 0.0.0.0:7052

  # When used as peer config, this represents the endpoint to other peers
  # in the same organization. For peers in other organization, see
  # gossip.externalEndpoint for more info.
  # When used as CLI config, this means the peer's endpoint to interact with
  address: 0.0.0.0:7051

  # Whether the Peer should programmatically determine its address
  # This case is useful for docker containers.
  # When set to true, will override peer address.
  addressAutoDetect: false

  # Settings for the Peer's gateway server.
  gateway:
    # Whether the gateway is enabled for this Peer.
    enabled: true
    # endorsementTimeout is the duration the gateway waits for a response
    # from other endorsing peers before returning a timeout error to the client.
    endorsementTimeout: 30s
    # broadcastTimeout is the duration the gateway waits for a response
    # from ordering nodes before returning a timeout error to the client.
    broadcastTimeout: 30s
    # dialTimeout is the duration the gateway waits for a connection
    # to other network nodes.
    dialTimeout: 2m

  # Keepalive settings for peer server and clients
  keepalive:
    # Interval is the duration after which if the server does not see
    # any activity from the client it pings the client to see if it's alive
    interval: 7200s
    # Timeout is the duration the server waits for a response
    # from the client after sending a ping before closing the connection
    timeout: 20s
    # MinInterval is the minimum permitted time between client pings.
    # If clients send pings more frequently, the peer server will
    # disconnect them
    minInterval: 60s
    # Client keepalive settings for communicating with other peer nodes
    client:
      # Interval is the time between pings to peer nodes.  This must
      # greater than or equal to the minInterval specified by peer
      # nodes
      interval: 60s
      # Timeout is the duration the client waits for a response from
      # peer nodes before closing the connection
      timeout: 20s
    # DeliveryClient keepalive settings for communication with ordering
    # nodes.
    deliveryClient:
      # Interval is the time between pings to ordering nodes.  This must
      # greater than or equal to the minInterval specified by ordering
      # nodes.
      interval: 60s
      # Timeout is the duration the client waits for a response from
      # ordering nodes before closing the connection
      timeout: 20s

  # Gossip related configuration
  gossip:
    # Bootstrap set to initialize gossip with.
    # This is a list of other peers that this peer reaches out to at startup.
    # Important: The endpoints here have to be endpoints of peers in the same
    # organization, because the peer would refuse connecting to these endpoints
    # unless they are in the same organization as the peer.
    bootstrap: 127.0.0.1:7051

    # NOTE: orgLeader and useLeaderElection parameters are mutual exclusive.
    # Setting both to true would result in the termination of the peer
    # since this is undefined state. If the peers are configured with
    # useLeaderElection=false, make sure there is at least 1 peer in the
    # organization that its orgLeader is set to true.

    # Defines whenever peer will initialize dynamic algorithm for
    # "leader" selection, where leader is the peer to establish
    # connection with ordering service and use delivery protocol
    # to pull ledger blocks from ordering service.
    useLeaderElection: false
    # Statically defines peer to be an organization "leader".
    # Organization leaders maintain connection with ordering service
    # and pulls blocks as they are created. Optionally, leader peers
    # may disseminate pulled blocks to peers in its own organization
    # based on the peer.deliveryclient.blockGossipEnabled setting below.
    # Multiple peers or all peers in an organization
    # may be configured as org leaders, so that they all pull
    # blocks directly from ordering service.
    orgLeader: true

    # Interval for membershipTracker polling
    membershipTrackerInterval: 5s

    # Overrides the endpoint that the peer publishes to peers
    # in its organization. For peers in foreign organizations
    # see 'externalEndpoint'
    endpoint:
    # Maximum count of blocks stored in memory
    maxBlockCountToStore: 10
    # Max time between consecutive message pushes(unit: millisecond)
    maxPropagationBurstLatency: 10ms
    # Max number of messages stored until a push is triggered to remote peers
    maxPropagationBurstSize: 10
    # Number of times a message is pushed to remote peers
    propagateIterations: 1
    # Number of peers selected to push messages to
    propagatePeerNum: 3
    # Determines frequency of pull phases(unit: second)
    # Must be greater than digestWaitTime + responseWaitTime
    pullInterval: 4s
    # Number of peers to pull from
    pullPeerNum: 3
    # Determines frequency of pulling state info messages from peers(unit: second)
    requestStateInfoInterval: 4s
    # Determines frequency of pushing state info messages to peers(unit: second)
    publishStateInfoInterval: 4s
    # Maximum time a stateInfo message is kept until expired
    stateInfoRetentionInterval:
    # Time from startup certificates are included in Alive messages(unit: second)
    publishCertPeriod: 10s
    # Should we skip verifying block messages or not (currently not in use)
    skipBlockVerification: false
    # Dial timeout(unit: second)
    dialTimeout: 3s
    # Connection timeout(unit: second)
    connTimeout: 2s
    # Buffer size of received messages
    recvBuffSize: 20
    # Buffer size of sending messages
    sendBuffSize: 200
    # Time to wait before pull engine processes incoming digests (unit: second)
    # Should be slightly smaller than requestWaitTime
    digestWaitTime: 1s
    # Time to wait before pull engine removes incoming nonce (unit: milliseconds)
    # Should be slightly bigger than digestWaitTime
    requestWaitTime: 1500ms
    # Time to wait before pull engine ends pull (unit: second)
    responseWaitTime: 2s
    # Alive check interval(unit: second)
    aliveTimeInterval: 5s
    # Alive expiration timeout(unit: second)
    aliveExpirationTimeout: 25s
    # Reconnect interval(unit: second)
    reconnectInterval: 25s
    # Max number of attempts to connect to a peer
    maxConnectionAttempts: 120
    # Message expiration factor for alive messages
    msgExpirationFactor: 20
    # This is an endpoint that is published to peers outside of the organization.
    # If this isn't set, the peer will not be known to other organizations and will not be exposed via service discovery.
    externalEndpoint:
    # Leader election service configuration
    election:
      # Longest time peer waits for stable membership during leader election startup (unit: second)
      startupGracePeriod: 15s
      # Interval gossip membership samples to check its stability (unit: second)
      membershipSampleInterval: 1s
      # Time passes since last declaration message before peer decides to perform leader election (unit: second)
      leaderAliveThreshold: 10s
      # Time between peer sends propose message and declares itself as a leader (sends declaration message) (unit: second)
      leaderElectionDuration: 5s

    pvtData:
      # pullRetryThreshold determines the maximum duration of time private data corresponding for a given block
      # would be attempted to be pulled from peers until the block would be committed without the private data
      pullRetryThreshold: 60s
      # As private data enters the transient store, it is associated with the peer's ledger's height at that time.
      # transientstoreMaxBlockRetention defines the maximum difference between the current ledger's height upon commit,
      # and the private data residing inside the transient store that is guaranteed not to be purged.
      # Private data is purged from the transient store when blocks with sequences that are multiples
      # of transientstoreMaxBlockRetention are committed.
      transientstoreMaxBlockRetention: 20000
      # pushAckTimeout is the maximum time to wait for an acknowledgement from each peer
      # at private data push at endorsement time.
      pushAckTimeout: 3s
      # Block to live pulling margin, used as a buffer
      # to prevent peer from trying to pull private data
      # from peers that is soon to be purged in next N blocks.
      # This helps a newly joined peer catch up to current
      # blockchain height quicker.
      btlPullMargin: 10
      # the process of reconciliation is done in an endless loop, while in each iteration reconciler tries to
      # pull from the other peers the most recent missing blocks with a maximum batch size limitation.
      # reconcileBatchSize determines the maximum batch size of missing private data that will be reconciled in a
      # single iteration.
      reconcileBatchSize: 10
      # reconcileSleepInterval determines the time reconciler sleeps from end of an iteration until the beginning
      # of the next reconciliation iteration.
      reconcileSleepInterval: 1m
      # reconciliationEnabled is a flag that indicates whether private data reconciliation is enable or not.
      reconciliationEnabled: true
      # skipPullingInvalidTransactionsDuringCommit is a flag that indicates whether pulling of invalid
      # transaction's private data from other peers need to be skipped during the commit time and pulled
      # only through reconciler.
      skipPullingInvalidTransactionsDuringCommit: false
      # implicitCollectionDisseminationPolicy specifies the dissemination  policy for the peer's own implicit collection.
      # When a peer endorses a proposal that writes to its own implicit collection, below values override the default values
      # for disseminating private data.
      # Note that it is applicable to all channels the peer has joined. The implication is that requiredPeerCount has to
      # be smaller than the number of peers in a channel that has the lowest numbers of peers from the organization.
      implicitCollectionDisseminationPolicy:
        # requiredPeerCount defines the minimum number of eligible peers to which the peer must successfully
        # disseminate private data for its own implicit collection during endorsement. Default value is 0.
        requiredPeerCount: 0
        # maxPeerCount defines the maximum number of eligible peers to which the peer will attempt to
        # disseminate private data for its own implicit collection during endorsement. Default value is 1.
        maxPeerCount: 1

    # Gossip state transfer related configuration
    state:
      # Indicates whether state transfer is enabled.
      # State transfer enabled allows a peer that is not a leader
      # to sync up missed blocks from other peers.
      # Default value is false since the recommended value of peer.gossip.orgleader is true.
      # Keep in mind that when peer.gossip.useLeaderElection is true
      # and there are several peers in the organization,
      # or peer.gossip.useLeaderElection is false alongside with
      # peer.gossip.orgleader being false, the peer's ledger may lag behind
      # the rest of the peers and will never catch up due to state transfer
      # being disabled.
      enabled: false
      # checkInterval interval to check whether peer is lagging behind enough to
      # request blocks via state transfer from another peer.
      checkInterval: 10s
      # responseTimeout amount of time to wait for state transfer response from
      # other peers
      responseTimeout: 3s
      # batchSize the number of blocks to request via state transfer from another peer
      batchSize: 10
      # blockBufferSize reflects the size of the re-ordering buffer
      # which captures blocks and takes care to deliver them in order
      # down to the ledger layer. The actual buffer size is bounded between
      # 0 and 2*blockBufferSize, each channel maintains its own buffer
      blockBufferSize: 20
      # maxRetries maximum number of re-tries to ask
      # for single state transfer request
      maxRetries: 3

  # TLS Settings
  tls:
    # Require server-side TLS
    enabled: false
    # Require client certificates / mutual TLS for inbound connections.
    # Note that clients that are not configured to use a certificate will
    # fail to connect to the peer.
    clientAuthRequired: false
    # X.509 certificate used for TLS server
    cert:
      file: tls/server.crt
    # Private key used for TLS server
    key:
      file: tls/server.key
    # rootcert.file represents the trusted root certificate chain used for verifying certificates
    # of other nodes during outbound connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    rootcert:
      file: tls/ca.crt
    # If mutual TLS is enabled, clientRootCAs.files contains a list of additional root certificates
    # used for verifying certificates of client connections.
    # It augments the set of TLS CA certificates available from the MSPs of each channel‚Äôs configuration.
    # Minimally, set your organization's TLS CA root certificate so that the peer can receive join channel requests.
    clientRootCAs:
      files:
        - tls/ca.crt
    # Private key used for TLS when making client connections.
    # If not set, peer.tls.key.file will be used instead
    clientKey:
      file:
    # X.509 certificate used for TLS when making client connections.
    # If not set, peer.tls.cert.file will be used instead
    clientCert:
      file:

  # Authentication contains configuration parameters related to authenticating
  # client messages
  authentication:
    # the acceptable difference between the current server time and the
    # client's time as specified in a client request message
    # this value is used for delivery service and
    # endorsement service (if the authFilter is enabled)
    timewindow: 15m

  # Path on the file system where peer will store data (eg ledger). This
  # location must be access control protected to prevent unintended
  # modification that might corrupt the peer operations.
  # The path may be relative to FABRIC_CFG_PATH or an absolute path.
  fileSystemPath: /var/hyperledger/production

  # BCCSP (Blockchain crypto provider): Select which crypto implementation or
  # library to use
  BCCSP:
    Default: SW
    # Settings for the SW crypto provider (i.e. when DEFAULT: SW)
    SW:
      # TODO: The default Hash and Security level needs refactoring to be
      # fully configurable. Changing these defaults requires coordination
      # SHA2 is hardcoded in several places, not only BCCSP
      Hash: SHA2
      Security: 256
      # Location of Key Store
      FileKeyStore:
        # If "", defaults to 'mspConfigPath'/keystore
        KeyStore:
    # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)
    PKCS11:
      # Location of the PKCS11 module library
      Library:
      # Token Label
      Label:
      # User PIN
      Pin:
      Hash:
      Security:
      SoftwareVerify:
      Immutable:
      AltID:
      KeyIds:

  # Path on the file system where peer will find MSP local configurations
  # The path may be relative to FABRIC_CFG_PATH or an absolute path.
  mspConfigPath: msp

  # Identifier of the local MSP
  # ----!!!!IMPORTANT!!!-!!!IMPORTANT!!!-!!!IMPORTANT!!!!----
  # Deployers need to change the value of the localMspId string.
  # In particular, the name of the local MSP ID of a peer needs
  # to match the name of one of the MSPs in each of the channel
  # that this peer is a member of. Otherwise this peer's messages
  # will not be identified as valid by other nodes.
  localMspId: SampleOrg

  # CLI common client config options
  client:
    # connection timeout
    connTimeout: 3s

  # Delivery service related config
  deliveryclient:
    # Enables this peer to disseminate blocks it pulls from the ordering service
    # to other peers in the same organization via gossip.
    # Note that 'gossip.state.enabled' controls point to point block replication
    # of blocks committed in the past.
    blockGossipEnabled: false
    # It sets the total time the delivery service may spend in reconnection
    # attempts until its retry logic gives up and returns an error,
    # ignored if peer is a static leader
    reconnectTotalTimeThreshold: 3600s

    # It sets the delivery service <-> ordering service node connection timeout
    connTimeout: 3s

    # It sets the delivery service maximal delay between consecutive retries.
    # Time between retries will have exponential backoff until hitting this threshold.
    reConnectBackoffThreshold: 3600s

    # If a certain header from a header receiver is in front of the block receiver for more that this time, a
    # censorship event is declared and the block source is changed.
    blockCensorshipTimeoutKey: 30s

    # The initial value of the actual retry interval, which is increased on every failed retry
    minimalReconnectInterval: 100ms

    # A list of orderer endpoint addresses which should be overridden
    # when found in channel configurations.
    addressOverrides:
      # - from:
      #   to:
      #   caCertsFile:
      # - from:
      #   to:
      #   caCertsFile:

    # Determines which delivery client will be used when consensus type is "BFT"
    # (when consensus type is "etcdraft" this key is ignored).
    # "simple" - use CFT deliverer
    # "cluster" - use BFT deliverer
    policy: cluster

  # Type for the local MSP - by default it's of type bccsp
  localMspType: bccsp

  # Used with Go profiling tools only in none production environment. In
  # production, it should be disabled (eg enabled: false)
  profile:
    enabled: false
    listenAddress: 0.0.0.0:6060

  # Handlers defines custom handlers that can filter and mutate
  # objects passing within the peer, such as:
  #   Auth filter - reject or forward proposals from clients
  #   Decorators  - append or mutate the chaincode input passed to the chaincode
  #   Endorsers   - Custom signing over proposal response payload and its mutation
  # Valid handler definition contains:
  #   - A name which is a factory method name defined in
  #     core/handlers/library/library.go for statically compiled handlers
  #   - library path to shared object binary for pluggable filters
  # Auth filters and decorators are chained and executed in the order that
  # they are defined. For example:
  # authFilters:
  #   - name: FilterOne
  #     library: /opt/lib/filter.so
  #   - name: FilterTwo
  # decorators:
  #   - name: DecoratorOne
  #   - name: DecoratorTwo
  #     library: /opt/lib/decorator.so
  # Endorsers are configured as a map that its keys are the endorsement system chaincodes that are being overridden.
  # Below is an example that overrides the default ESCC and uses an endorsement plugin that has the same functionality
  # as the default ESCC.
  # If the 'library' property is missing, the name is used as the constructor method in the builtin library similar
  # to auth filters and decorators.
  # endorsers:
  #   escc:
  #     name: DefaultESCC
  #     library: /etc/hyperledger/fabric/plugin/escc.so
  handlers:
    authFilters:
      - name: DefaultAuth
      - name: ExpirationCheck # This filter checks identity x509 certificate expiration
      - name: TimeWindowCheck # This filter checks the timestamp of an proposal request with the peer.authentication.timewindow parameter from core.yaml
    decorators:
      - name: DefaultDecorator
    endorsers:
      escc:
        name: DefaultEndorsement
        library:
    validators:
      vscc:
        name: DefaultValidation
        library:

        # library: /etc/hyperledger/fabric/plugin/escc.so
  # Number of goroutines that will execute transaction validation in parallel.
  # By default, the peer chooses the number of CPUs on the machine. Set this
  # variable to override that choice.
  # NOTE: overriding this value might negatively influence the performance of
  # the peer so please change this value only if you know what you're doing
  validatorPoolSize:

  # The discovery service is used by clients to query information about peers,
  # such as - which peers have joined a certain channel, what is the latest
  # channel config, and most importantly - given a chaincode and a channel,
  # what possible sets of peers satisfy the endorsement policy.
  discovery:
    enabled: true
    # Whether the authentication cache is enabled or not.
    authCacheEnabled: true
    # The maximum size of the cache, after which a purge takes place
    authCacheMaxSize: 1000
    # The proportion (0 to 1) of entries that remain in the cache after the cache is purged due to overpopulation
    authCachePurgeRetentionRatio: 0.75
    # Whether to allow non-admins to perform non channel scoped queries.
    # When this is false, it means that only peer admins can perform non channel scoped queries.
    orgMembersAllowedAccess: false

  # Limits is used to configure some internal resource limits.
  limits:
    # Concurrency limits the number of concurrently running requests to a service on each peer.
    # Currently this option is only applied to endorser service and deliver service.
    # When the property is missing or the value is 0, the concurrency limit is disabled for the service.
    concurrency:
      # endorserService limits concurrent requests to endorser service that handles chaincode deployment, query and invocation,
      # including both user chaincodes and system chaincodes.
      endorserService: 2500
      # deliverService limits concurrent event listeners registered to deliver service for blocks and transaction events.
      deliverService: 2500
      # gatewayService limits concurrent requests to gateway service that handles the submission and evaluation of transactions.
      gatewayService: 500

  # Since all nodes should be consistent it is recommended to keep
  # the default value of 100MB for MaxRecvMsgSize & MaxSendMsgSize
  # Max message size in bytes GRPC server and client can receive
  maxRecvMsgSize: 104857600
  # Max message size in bytes GRPC server and client can send
  maxSendMsgSize: 104857600

###############################################################################
#
#    VM section
#
###############################################################################
vm:
  # Endpoint of the vm management system.  For docker can be one of the following in general
  # unix:///var/run/docker.sock
  # http://localhost:2375
  # https://localhost:2376
  # If you utilize external chaincode builders and don't need the default Docker chaincode builder,
  # the endpoint should be unconfigured so that the peer's Docker health checker doesn't get registered.
  endpoint: unix:///var/run/docker.sock

  # settings for docker vms
  docker:
    tls:
      enabled: false
      ca:
        file: docker/ca.crt
      cert:
        file: docker/tls.crt
      key:
        file: docker/tls.key

    # Enables/disables the standard out/err from chaincode containers for
    # debugging purposes
    attachStdout: false

    # Parameters on creating docker container.
    # Container may be efficiently created using ipam & dns-server for cluster
    # NetworkMode - sets the networking mode for the container. Supported
    # standard values are: `host`(default),`bridge`,`ipvlan`,`none`.
    # Dns - a list of DNS servers for the container to use.
    # Note:  `Privileged` `Binds` `Links` and `PortBindings` properties of
    # Docker Host Config are not supported and will not be used if set.
    # LogConfig - sets the logging driver (Type) and related options
    # (Config) for Docker. For more info,
    # https://docs.docker.com/engine/admin/logging/overview/
    # Note: Set LogConfig using Environment Variables is not supported.
    hostConfig:
      NetworkMode: host
      Dns:
        # - 192.168.0.1
      LogConfig:
        Type: json-file
        Config:
          max-size: "50m"
          max-file: "5"
      Memory: 2147483648

###############################################################################
#
#    Chaincode section
#
###############################################################################
chaincode:
  # The id is used by the Chaincode stub to register the executing Chaincode
  # ID with the Peer and is generally supplied through ENV variables
  # the `path` form of ID is provided when installing the chaincode.
  # The `name` is used for all other requests and can be any string.
  id:
    path:
    name:

  # Generic builder image with Go pre-installed.
  # TWO_DIGIT_VERSION represents Fabric major.minor version.
  builder: $(DOCKER_NS)/fabric-ccenv:$(TWO_DIGIT_VERSION)

  # Enables/disables force pulling of the base docker images (listed below)
  # during user chaincode instantiation.
  # Useful when using moving image tags (such as :latest)
  pull: false

  golang:
    # Compiled Go chaincodes will be copied to the fabric-baseos runtime image.
    # TWO_DIGIT_VERSION represents Fabric major.minor version.
    runtime: $(DOCKER_NS)/fabric-baseos:$(TWO_DIGIT_VERSION)

    # whether or not golang chaincode should be linked dynamically
    dynamicLink: false

  java:
    # This is an image based on eclipse temurin with addition compiler
    # tools added for java shim layer packaging.
    # This image is packed with shim layer libraries that are necessary
    # for Java chaincode runtime.
    runtime: $(DOCKER_NS)/fabric-javaenv:2.5

  node:
    # This is an image based on node:$(NODE_VER)-alpine
    runtime: $(DOCKER_NS)/fabric-nodeenv:2.5

  # List of directories to treat as external builders and launchers for
  # chaincode. The external builder detection processing will iterate over the
  # builders in the order specified below.
  # If you don't need to fallback to the default Docker builder, also unconfigure vm.endpoint above.
  # To override this property via env variable use CORE_CHAINCODE_EXTERNALBUILDERS: [{name: x, path: dir1}, {name: y, path: dir2}]
  # The path must be an absolute path.
  externalBuilders:
    - name: ccaas_builder
      path: /opt/hyperledger/ccaas_builder
      propagateEnvironment:
        - CHAINCODE_AS_A_SERVICE_BUILDER_CONFIG

  # The maximum duration to wait for the chaincode build and install process
  # to complete.
  installTimeout: 300s

  # Timeout duration for starting up a container and waiting for Register
  # to come through.
  startuptimeout: 300s

  # Timeout duration for Invoke and Init calls to prevent runaway.
  # This timeout is used by all chaincodes in all the channels, including
  # system chaincodes.
  # Note that during Invoke, if the image is not available (e.g. being
  # cleaned up when in development environment), the peer will automatically
  # build the image, which might take more time. In production environment,
  # the chaincode image is unlikely to be deleted, so the timeout could be
  # reduced accordingly.
  executetimeout: 30s

  # There are 2 modes: "dev" and "net".
  # In dev mode, user runs the chaincode after starting peer from
  # command line on local machine.
  # In net mode, peer will run chaincode in a docker container.
  mode: net

  # keepalive in seconds. In situations where the communication goes through a
  # proxy that does not support keep-alive, this parameter will maintain connection
  # between peer and chaincode.
  # A value <= 0 turns keepalive off
  keepalive: 0

  # enabled system chaincodes
  system:
    _lifecycle: enable
    cscc: enable
    lscc: enable
    qscc: enable

  # Logging section for the chaincode container
  logging:
    # Default level for all loggers within the chaincode container
    level: info
    # Override default level for the 'shim' logger
    shim: warning
    # Format for the chaincode container logs
    format: "%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -> %{level:.4s} %{id:03x}%{color:reset} %{message}"

    # RuntimeParams section for parameters that are passed to chaincode
    # to specify additional operation modes in which the peer operates.
  runtimeParams:
    # UseWriteBatch an indication that the peer can accept changes from chaincode in batches
    useWriteBatch: true
    # MaxSizeWriteBatch maximum batch size for the change segment
    maxSizeWriteBatch: 1000
    # UseGetMultipleKeys an indication that the peer can handle get multiple keys
    useGetMultipleKeys: true
    # MaxSizeGetMultipleKeys maximum size of batches with get multiple keys
    maxSizeGetMultipleKeys: 1000

###############################################################################
#
#    Ledger section - ledger configuration encompasses both the blockchain
#    and the state
#
###############################################################################
ledger:
  blockchain:

  state:
    # stateDatabase - options are "goleveldb", "CouchDB"
    # goleveldb - default state database stored in goleveldb.
    # CouchDB - store state database in CouchDB
    stateDatabase: goleveldb
    # Limit on the number of records to return per query
    totalQueryLimit: 100000
    couchDBConfig:
      # It is recommended to run CouchDB on the same server as the peer, and
      # not map the CouchDB container port to a server port in docker-compose.
      # Otherwise proper security must be provided on the connection between
      # CouchDB client (on the peer) and server.
      couchDBAddress: 127.0.0.1:5984
      # This username must have read and write authority on CouchDB
      username:
      # The password is recommended to pass as an environment variable
      # during start up (eg CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD).
      # If it is stored here, the file must be access control protected
      # to prevent unintended users from discovering the password.
      password:
      # Number of retries for CouchDB errors
      maxRetries: 3
      # Number of retries for CouchDB errors during peer startup.
      # The delay between retries doubles for each attempt.
      # Default of 10 retries results in 11 attempts over 2 minutes.
      maxRetriesOnStartup: 10
      # CouchDB request timeout (unit: duration, e.g. 20s)
      requestTimeout: 35s
      # Limit on the number of records per each CouchDB query
      # Note that chaincode queries are only bound by totalQueryLimit.
      # Internally the chaincode may execute multiple CouchDB queries,
      # each of size internalQueryLimit.
      internalQueryLimit: 1000
      # Limit on the number of records per CouchDB bulk update batch
      maxBatchUpdateSize: 1000
      # Create the _global_changes system database
      # This is optional.  Creating the global changes database will require
      # additional system resources to track changes and maintain the database
      createGlobalChangesDB: false
      # CacheSize denotes the maximum mega bytes (MB) to be allocated for the in-memory state
      # cache. Note that CacheSize needs to be a multiple of 32 MB. If it is not a multiple
      # of 32 MB, the peer would round the size to the next multiple of 32 MB.
      # To disable the cache, 0 MB needs to be assigned to the cacheSize.
      cacheSize: 64

  history:
    # enableHistoryDatabase - options are true or false
    # Indicates if the history of key updates should be stored.
    # All history 'index' will be stored in goleveldb, regardless if using
    # CouchDB or alternate database for the state.
    enableHistoryDatabase: true

  pvtdataStore:
    # the maximum db batch size for converting
    # the ineligible missing data entries to eligible missing data entries
    collElgProcMaxDbBatchSize: 5000
    # the minimum duration (in milliseconds) between writing
    # two consecutive db batches for converting the ineligible missing data entries to eligible missing data entries
    collElgProcDbBatchesInterval: 1000
    # The missing data entries are classified into two categories:
    # (1) prioritized
    # (2) deprioritized
    # Initially, all missing data are in the prioritized list. When the
    # reconciler is unable to fetch the missing data from other peers,
    # the unreconciled missing data would be moved to the deprioritized list.
    # The reconciler would retry deprioritized missing data after every
    # deprioritizedDataReconcilerInterval (unit: minutes). Note that the
    # interval needs to be greater than the reconcileSleepInterval
    deprioritizedDataReconcilerInterval: 60m
    # The frequency to purge private data (in number of blocks).
    # Private data is purged from the peer's private data store based on
    # the collection property blockToLive or an explicit chaincode call to PurgePrivateData().
    purgeInterval: 100
    # Whether to log private data keys purged from private data store (INFO level) when explicitly purged via chaincode
    purgedKeyAuditLogging: true

  snapshots:
    # Path on the file system where peer will store ledger snapshots
    # The path must be an absolute path.
    rootDir: /var/hyperledger/production/snapshots

###############################################################################
#
#    Operations section
#
###############################################################################
operations:
  # host and port for the operations server
  listenAddress: 127.0.0.1:9443

  # TLS configuration for the operations endpoint
  tls:
    # TLS enabled
    enabled: false

    # path to PEM encoded server certificate for the operations server
    # The paths in this section may be relative to FABRIC_CFG_PATH or an absolute path.
    cert:
      file:

    # path to PEM encoded server key for the operations server
    key:
      file:

    # most operations service endpoints require client authentication when TLS
    # is enabled. clientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    clientAuthRequired: false

    # paths to PEM encoded ca certificates to trust for client authentication
    clientRootCAs:
      files: []

###############################################################################
#
#    Metrics section
#
###############################################################################
metrics:
  # metrics provider is one of statsd, prometheus, or disabled
  provider: disabled

  # statsd configuration
  statsd:
    # network type: tcp or udp
    network: udp

    # statsd server address
    address: 127.0.0.1:8125

    # the interval at which locally cached counters and gauges are pushed
    # to statsd; timings are pushed immediately
    writeInterval: 10s

    # prefix is prepended to all emitted statsd metrics
    prefix:



./config/network.yaml
----------------------------------------
network:
  name: "my-fabric-network"
  domain: "example.com"
  version: "3.1.1"

organizations:
  - name: "Org1"
    msp_id: "Org1MSP"
    peers:
      - name: "peer0"
        port: 7051
        chaincode_port: 7052
      - name: "peer1"
        port: 8051
        chaincode_port: 8052
    ca:
      port: 7054

  - name: "Org2"
    msp_id: "Org2MSP"
    peers:
      - name: "peer0"
        port: 9051
        chaincode_port: 9052
    ca:
      port: 8054

orderer:
  type: "etcdraft"
  nodes:
    - name: "orderer0"
      port: 7050
      admin_port: 7053

channels:
  - name: "mychannel"
    participating_orgs: ["Org1", "Org2"]

chaincodes:
  - name: "basic_asset"
    version: "1.0"
    pdc: # Defini√ß√£o de Private Data Collections
      - name: "collectionMarbles"
        policy: "OR('Org1MSP.member', 'Org2MSP.member')"
        required_peer_count: 1
        max_peer_count: 2
        block_to_live: 1000


./config/versions.yaml
----------------------------------------
# Defini√ß√µes de Vers√£o para o Ambiente Hyperledger Fabric
versions:
  fabric: "3.1.1"           # Vers√£o dos bin√°rios e imagens peer/orderer
  fabric_ca: "1.5.13"       # Vers√£o da CA (geralmente tem versionamento pr√≥prio)
  go: "1.22.0"              # Fabric 3.x requer Go 1.22+
  docker: "20.10"           # Vers√£o m√≠nima do Docker
  docker_compose: "2.20"    # Vers√£o m√≠nima do Docker Compose (V2)

# Configura√ß√µes globais de imagem
images:
  org_hyperledger: "hyperledger" # Prefixo da imagem docker


./config/orderer.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

---
################################################################################
#
#   Orderer Configuration
#
#   - This controls the type and configuration of the orderer.
#
################################################################################
General:
  # Listen address: The IP on which to bind to listen.
  ListenAddress: 127.0.0.1

  # Listen port: The port on which to bind to listen.
  ListenPort: 7050

  # TLS: TLS settings for the GRPC server.
  TLS:
    # Require server-side TLS
    Enabled: false
    # PrivateKey governs the file location of the private key of the TLS certificate.
    PrivateKey: tls/server.key
    # Certificate governs the file location of the server TLS certificate.
    Certificate: tls/server.crt
    # RootCAs contains a list of additional root certificates used for verifying certificates
    # of other orderer nodes during outbound connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    RootCAs:
      - tls/ca.crt
    # Require client certificates / mutual TLS for inbound connections.
    ClientAuthRequired: false
    # If mutual TLS is enabled, ClientRootCAs contains a list of additional root certificates
    # used for verifying certificates of client connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    ClientRootCAs:
  # Keepalive settings for the GRPC server.
  Keepalive:
    # ServerMinInterval is the minimum permitted time between client pings.
    # If clients send pings more frequently, the server will
    # disconnect them.
    ServerMinInterval: 60s
    # ServerInterval is the time between pings to clients.
    ServerInterval: 7200s
    # ServerTimeout is the duration the server waits for a response from
    # a client before closing the connection.
    ServerTimeout: 20s
  # Config defines the configuration options for backoff GRPC client.
  Backoff:
    # BaseDelay is the amount of time to backoff after the first failure.
    BaseDelay: 1s
    # Multiplier is the factor with which to multiply backoffs after a
    # failed retry. Should ideally be greater than 1.
    Multiplier: 1.6
    # MaxDelay is the upper bound of backoff delay.
    MaxDelay: 2m

  # Since all nodes should be consistent it is recommended to keep
  # the default value of 100MB for MaxRecvMsgSize & MaxSendMsgSize
  # Max message size in bytes the GRPC server and client can receive
  MaxRecvMsgSize: 104857600
  # Max message size in bytes the GRPC server and client can send
  MaxSendMsgSize: 104857600
  # Throttling prevents clients from sending too many transactions
  # per second to the broadcast API of this node.
  # It is only enforced when the Rate is non-zero, and when the client
  # connects using mutual TLS.
  # The effective rate of transactions is divided across all clients
  # and organizations at a given unit of time governed by the inactivity timeout.
  # When a client's rate of transaction submission exhausts its allocated budget,
  # it is throttled until additional "budget" is allocated (it is allocated once per second).
  Throttling:
    # Rate is the maximum rate (transactions per second) for all clients combined.
    # A zero rate disables throttling.
    Rate: 0
    # InactivityTimeout defines the time frame after which
    # inactive clients are pruned from memory and are not considered
    # when allocating the budget for throttling per client.
    InactivityTimeout: 5s

  # Cluster settings for ordering service nodes that communicate with other ordering service nodes
  # such as Raft based ordering service.
  Cluster:
    # SendBufferSize is the maximum number of messages in the egress buffer.
    # Consensus messages are dropped if the buffer is full, and transaction
    # messages are waiting for space to be freed.
    SendBufferSize: 100

    # ClientCertificate governs the file location of the client TLS certificate
    # used to establish mutual TLS connections with other ordering service nodes.
    # If not set, the server General.TLS.Certificate is re-used.
    ClientCertificate:
    # ClientPrivateKey governs the file location of the private key of the client TLS certificate.
    # If not set, the server General.TLS.PrivateKey is re-used.
    ClientPrivateKey:

    # The below 4 properties should be either set together, or be unset together.
    # If they are set, then the orderer node uses a separate listener for intra-cluster
    # communication. If they are unset, then the general orderer listener is used.
    # This is useful if you want to use a different TLS server certificates on the
    # client-facing and the intra-cluster listeners.

    # ListenPort defines the port on which the cluster listens to connections.
    ListenPort:
    # ListenAddress defines the IP on which to listen to intra-cluster communication.
    ListenAddress:
    # ServerCertificate defines the file location of the server TLS certificate used for intra-cluster
    # communication.
    ServerCertificate:
    # ServerPrivateKey defines the file location of the private key of the TLS certificate.
    ServerPrivateKey:

    # ReplicationPolicy defines how blocks are replicated between orderers.
    # Permitted values:
    # in BFT: "simple" | "consensus" (default);
    # in etcdraft: ignored, (always "simple", regardless of value in config).
    # When running a Raft orderer or with ReplicationPolicy set to 'simple', an orderer
    # replicates blocks from a single orderer node.
    # When running a BFT orderer with ReplicationPolicy set to 'consensus', the orderer
    # replicates blocks from a single orderer node, but replicates block headers with signatures
    # from other orderer nodes, and if it suspects the former node withholds blocks from it,
    # it switches to a new orderer as a source of blocks.
    ReplicationPolicy:

  # LocalMSPDir is where to find the private crypto material needed by the
  # orderer. It is set relative here as a default for dev environments but
  # should be changed to the real location in production.
  LocalMSPDir: msp

  # LocalMSPID is the identity to register the local MSP material with the MSP
  # manager. The sample organization defined in the
  # sample configuration provided has an MSP ID of "SampleOrg".
  LocalMSPID: SampleOrg

  # Enable an HTTP service for Go "pprof" profiling as documented at:
  # https://golang.org/pkg/net/http/pprof
  Profile:
    Enabled: false
    Address: 0.0.0.0:6060

  # BCCSP configures the blockchain crypto service providers.
  BCCSP:
    # Default specifies the preferred blockchain crypto service provider
    # to use. If the preferred provider is not available, the software
    # based provider ("SW") will be used.
    # Valid providers are:
    #  - SW: a software based crypto provider
    #  - PKCS11: a CA hardware security module crypto provider.
    Default: SW

    # SW configures the software based blockchain crypto provider.
    SW:
      # TODO: The default Hash and Security level needs refactoring to be
      # fully configurable. Changing these defaults requires coordination
      # SHA2 is hardcoded in several places, not only BCCSP
      Hash: SHA2
      Security: 256
      # Location of key store. If this is unset, a location will be
      # chosen using: 'LocalMSPDir'/keystore
      FileKeyStore:
        KeyStore:

    # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)
    PKCS11:
      # Location of the PKCS11 module library
      Library:
      # Token Label
      Label:
      # User PIN
      Pin:
      Hash:
      Security:
      FileKeyStore:
        KeyStore:

  # Authentication contains configuration parameters related to authenticating
  # client messages
  Authentication:
    # the acceptable difference between the current server time and the
    # client's time as specified in a client request message
    TimeWindow: 15m

################################################################################
#
#   SECTION: File Ledger
#
#   - This section applies to the configuration of the file ledger.
#
################################################################################
FileLedger:
  # Location: The directory to store the blocks in.
  Location: /var/hyperledger/production/orderer

################################################################################
#
#   Debug Configuration
#
#   - This controls the debugging options for the orderer
#
################################################################################
Debug:
  # BroadcastTraceDir when set will cause each request to the Broadcast service
  # for this orderer to be written to a file in this directory
  BroadcastTraceDir:

  # DeliverTraceDir when set will cause each request to the Deliver service
  # for this orderer to be written to a file in this directory
  DeliverTraceDir:

################################################################################
#
#   Operations Configuration
#
#   - This configures the operations server endpoint for the orderer
#
################################################################################
Operations:
  # host and port for the operations server
  ListenAddress: 127.0.0.1:8443

  # TLS configuration for the operations endpoint
  TLS:
    # TLS enabled
    Enabled: false

    # Certificate is the location of the PEM encoded TLS certificate
    Certificate:

    # PrivateKey points to the location of the PEM-encoded key
    PrivateKey:

    # Most operations service endpoints require client authentication when TLS
    # is enabled. ClientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    ClientAuthRequired: false

    # Paths to PEM encoded ca certificates to trust for client authentication
    ClientRootCAs: []

################################################################################
#
#   Metrics Configuration
#
#   - This configures metrics collection for the orderer
#
################################################################################
Metrics:
  # The metrics provider is one of statsd, prometheus, or disabled
  Provider: disabled

  # The statsd configuration
  Statsd:
    # network type: tcp or udp
    Network: udp

    # the statsd server address
    Address: 127.0.0.1:8125

    # The interval at which locally cached counters and gauges are pushed
    # to statsd; timings are pushed immediately
    WriteInterval: 30s

    # The prefix is prepended to all emitted statsd metrics
    Prefix:

################################################################################
#
#   Admin Configuration
#
#   - This configures the admin server endpoint for the orderer
#
################################################################################
Admin:
  # host and port for the admin server
  ListenAddress: 127.0.0.1:9443

  # TLS configuration for the admin endpoint
  TLS:
    # TLS enabled
    Enabled: false

    # Certificate is the location of the PEM encoded TLS certificate
    Certificate:

    # PrivateKey points to the location of the PEM-encoded key
    PrivateKey:

    # Most admin service endpoints require client authentication when TLS
    # is enabled. ClientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    #
    # NOTE: When TLS is enabled, the admin endpoint requires mutual TLS. The
    # orderer will panic on startup if this value is set to false.
    ClientAuthRequired: true

    # Paths to PEM encoded ca certificates to trust for client authentication
    ClientRootCAs: []

################################################################################
#
#   Channel participation API Configuration
#
#   - This provides the channel participation API configuration for the orderer.
#   - Channel participation uses the ListenAddress and TLS settings of the Admin
#     service.
#
################################################################################
ChannelParticipation:
  # Channel participation API is enabled. Deprecated: must be set to true.
  Enabled: true

  # The maximum size of the request body when joining a channel.
  MaxRequestBodySize: 1 MB

################################################################################
#
#   Consensus Configuration
#
#   - This section contains config options for a consensus plugin. It is opaque
#     to orderer, and completely up to consensus implementation to make use of.
#
################################################################################
Consensus:
  # The allowed key-value pairs here depend on consensus plugin. For etcd/raft,
  # we use following options:

  # WALDir specifies the location at which Write Ahead Logs for etcd/raft are
  # stored. Each channel will have its own subdir named after channel ID.
  WALDir: /var/hyperledger/production/orderer/etcdraft/wal

  # SnapDir specifies the location at which snapshots for etcd/raft are
  # stored. Each channel will have its own subdir named after channel ID.
  SnapDir: /var/hyperledger/production/orderer/etcdraft/snapshot



./scripts/check_reqs.sh
----------------------------------------
#!/bin/bash

source ./scripts/colors.sh

# Define o diret√≥rio raiz do projeto
# Se NETWORK_DIR vier do Python, usamos o pai dele como raiz, ou o diret√≥rio atual
PROJECT_ROOT=${NETWORK_DIR%/network} # Remove '/network' do final para pegar a raiz
if [ -z "$PROJECT_ROOT" ]; then
    PROJECT_ROOT="."
fi

# Adiciona ./bin local ao PATH temporariamente para verifica√ß√£o
export PATH=$PROJECT_ROOT/bin:$PATH

infoln "Verificando pr√©-requisitos para Fabric $FABRIC_VERSION e CA $CA_VERSION..."

# ---------------------------------------------------------
# 1. Verificar Docker
# ---------------------------------------------------------
if ! command -v docker &> /dev/null; then
    errorln "Docker n√£o encontrado! Instale o Docker Desktop ou Engine."
    exit 1
fi
DOCKER_V=$(docker --version)
successln "Docker encontrado: $DOCKER_V"

# ---------------------------------------------------------
# 2. Verificar Go (Opcional)
# ---------------------------------------------------------
if command -v go &> /dev/null; then
    CURRENT_GO=$(go version | awk '{print $3}' | sed 's/go//')
    if [[ "$CURRENT_GO" < "$GO_VERSION" ]]; then
        warnln "AVISO: Vers√£o do Go ($CURRENT_GO) √© menor que a recomendada ($GO_VERSION)"
    else
        successln "Go vers√£o $CURRENT_GO compat√≠vel."
    fi
else
    warnln "Go n√£o instalado (OK se n√£o for compilar Chaincode em Go)"
fi

# ---------------------------------------------------------
# 3. Verificar e Baixar Bin√°rios do Fabric
# ---------------------------------------------------------

NEED_INSTALL=false

if command -v configtxgen &> /dev/null; then
    FABRIC_BIN_VER=$(configtxgen -version | grep "Version:" | awk '{print $2}')
    
    if [[ "$FABRIC_BIN_VER" != "$FABRIC_VERSION" ]]; then
        warnln "Vers√£o local ($FABRIC_BIN_VER) difere da desejada ($FABRIC_VERSION)."
        NEED_INSTALL=true
    else
        successln "Bin√°rios do Fabric ($FABRIC_BIN_VER) j√° instalados corretamente."
    fi
else
    warnln "Bin√°rios do Fabric n√£o encontrados no PATH."
    NEED_INSTALL=true
fi

if [ "$NEED_INSTALL" = true ]; then
    infoln "Iniciando download dos bin√°rios do Fabric $FABRIC_VERSION..."
    
    # Entra na raiz do projeto
    pushd "$PROJECT_ROOT" > /dev/null

    # Baixa o script oficial
    curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh -o install-fabric.sh
    chmod +x install-fabric.sh

    # Executa a instala√ß√£o
    ./install-fabric.sh --fabric-version $FABRIC_VERSION --ca-version $CA_VERSION binary docker

    # Limpeza
    rm install-fabric.sh
    
    popd > /dev/null
    
    successln "Download e instala√ß√£o conclu√≠dos na pasta bin/ local."
fi

successln "--- Script check_reqs rodado com sucesso ---\n"


./scripts/colors.sh
----------------------------------------
#!/bin/bash

# Cores ANSI
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[1;33m"
BLUE="\033[0;34m"
CYAN="\033[0;36m"
RESET="\033[0m"

# Fun√ß√£o de info (azul)
infoln() {
    echo -e "${BLUE}[INFO] $1${RESET}"
}

# Fun√ß√£o de sucesso (verde)
successln() {
    echo -e "${GREEN}[SUCESSO] $1${RESET}"
}

# Fun√ß√£o de aviso (amarelo)
warnln() {
    echo -e "${YELLOW}[AVISO] $1${RESET}"
}

# Fun√ß√£o de erro (vermelho)
errorln() {
    echo -e "${RED}[ERRO] $1${RESET}"
}



./main.py
----------------------------------------
from src.path_manager import PathManager
from src.config_loader import ConfigLoader
from src.network_controller import NetworkController
from src.colors import Colors as co

def main():
    # 1. Configurar Caminhos
    paths = PathManager()

    # 2. Carregar Configura√ß√µes
    loader = ConfigLoader(paths.network_yaml, paths.versions_yaml)
    config = loader.load()

    # 3. Inicializar Controlador
    controller = NetworkController(config, paths)

    # 4. Verifica vers√µes e pr√©-requisitos
    try:
        controller.run_script("check_reqs.sh")
    except Exception as e:
        co.errorln(f"\n Erro nos pr√©-requisitos: {e}")
        return

if __name__ == "__main__":
    main()


./install-fabric.sh
----------------------------------------
#!/usr/bin/env bash
#
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

# A modified version of the Fabric bootstrap script
# Use positional arguments to select components to install
#
# Has exactly the same functional power of bootstrap.sh

### START OF CODE GENERATED BY Argbash v2.9.0  ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

# Default values
_positionals=()
_arg_comp=('' )

# if version not passed in, default to latest released version
# if ca version not passed in, default to latest released version
_arg_fabric_version="2.5.14"
_arg_ca_version="1.5.15"

OS=$(uname -s|tr '[:upper:]' '[:lower:]'|sed 's/mingw64_nt.*/windows/')
ARCH=$(uname -m | sed 's/x86_64/amd64/g' | sed 's/aarch64/arm64/g')
PLATFORM=${OS}-${ARCH}

# Fabric < 1.2 uses uname -m for architecture.
MARCH=$(uname -m)

HYPERLEDGER_NAMESPACE=hyperledger
DOCKER_NAMESPACE="${FABRIC_DOCKER_REGISTRY:-${HYPERLEDGER_NAMESPACE}}"


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='fc'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}


print_help()
{
	printf 'Usage: %s [-f|--fabric-version <arg>] [-c|--ca-version <arg>] <comp-1> [<comp-2>] ... [<comp-n>] ...\n' "$0"
	printf '\t%s\n' "<comp> Component to install, one or more of  docker | binary | samples | podman  First letter of component also accepted; If none specified docker | binary | samples is assumed"
	printf '\t%s\n' "-f, --fabric-version: FabricVersion (default: '2.5.14')"
	printf '\t%s\n' "-c, --ca-version: Fabric CA Version (default: '1.5.15')"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-f|--fabric-version)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_fabric_version="$2"
				shift
				;;
			--fabric-version=*)
				_arg_fabric_version="${_key##--fabric-version=}"
				;;
			-f*)
				_arg_fabric_version="${_key##-f}"
				;;
			-c|--ca-version)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_ca_version="$2"
				shift
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			--ca-version=*)
				_arg_ca_version="${_key##--ca-version=}"
				;;
			-c*)
				_arg_ca_version="${_key##-c}"
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'comp'"
	# test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_comp "
	_our_args=$((${#_positionals[@]} - 1))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_comp[$((ii + 1))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

# End of ARGBASH code

# dockerPull() pulls docker images from fabric and chaincode repositories
# note, if a docker image doesn't exist for a requested release, it will simply
# be skipped, since this script doesn't terminate upon errors.

singleImagePull() {
    #three_digit_image_tag is passed in, e.g. "1.4.7"
    local three_digit_image_tag=$1
    shift
    #two_digit_image_tag is derived, e.g. "1.4", especially useful as a local tag for two digit references
    local two_digit_image_tag
    two_digit_image_tag=$(echo "$three_digit_image_tag" | cut -d'.' -f1,2)


    while [[ $# -gt 0 ]]; do
        local component_name="$1"
        local registry
        registry="$(dockerComponentRegistry "${component_name}" "${three_digit_image_tag}")"
        local image_name="${registry}/fabric-${component_name}:${three_digit_image_tag}"

        echo "====>  ${image_name}"
        ${CONTAINER_CLI} pull "${image_name}"


        ${CONTAINER_CLI} tag "${image_name}" "${DOCKER_NAMESPACE}/fabric-${component_name}"
        ${CONTAINER_CLI} tag "${image_name}" "${DOCKER_NAMESPACE}/fabric-${component_name}:${two_digit_image_tag}"
        # Re-tag 3-digit version to ensure there is a tag without registry prefix
        ${CONTAINER_CLI} tag "${image_name}" "${DOCKER_NAMESPACE}/fabric-${component_name}:${three_digit_image_tag}"

        shift
    done
}

dockerComponentRegistry() {
    if [[ -n ${FABRIC_DOCKER_REGISTRY} ]]; then
        echo -n "${FABRIC_DOCKER_REGISTRY}"
        return
    fi

    local component="$1"
    local image_version="$2"

    # Remove trailing pre-release or metadata identifiers
    image_version="${image_version%%[-+]*}"

    case "${component}" in
        ca)
            echo -n "$(dockerCARegistry "${image_version}")/${HYPERLEDGER_NAMESPACE}"
            ;;
        *)
            echo -n "$(dockerFabricRegistry "${image_version}")/${HYPERLEDGER_NAMESPACE}"
            ;;
    esac
}

dockerCARegistry() {
    local version="$1"

    case "${version}" in
        1.[0-4].*|1.5.[0-9]|1.5.1[0-4])
            echo -n 'docker.io'
            ;;
        *)
            echo -n 'ghcr.io'
            ;;
    esac
}

dockerFabricRegistry() {
    local version="$1"

    case "${version}" in
        1.*|2.[0-4].*|2.5.[0-9]|2.5.10|3.0.0)
            echo -n 'docker.io'
            ;;
        *)
            echo -n 'ghcr.io'
            ;;
    esac
}

cloneSamplesRepo() {
    # clone (if needed) hyperledger/fabric-samples and checkout corresponding
    # version to the binaries and docker images to be downloaded
    if [ -d test-network ]; then
        # if we are in the fabric-samples repo, checkout corresponding version
        echo "==> Already in fabric-samples repo"
    elif [ -d fabric-samples ]; then
        # if fabric-samples repo already cloned and in current directory,
        # cd fabric-samples
        echo "===> Changing directory to fabric-samples"
        cd fabric-samples
    else
        echo "===> Cloning hyperledger/fabric-samples repo"
        git clone -b main https://github.com/hyperledger/fabric-samples.git && cd fabric-samples
    fi

    if GIT_DIR=.git git rev-parse v${VERSION} >/dev/null 2>&1; then
        echo "===> Checking out v${VERSION} of hyperledger/fabric-samples"
        git checkout -q v${VERSION}
    else
        echo "fabric-samples v${VERSION} does not exist, defaulting to main. fabric-samples main branch is intended to work with recent versions of fabric."
        git checkout -q main
    fi
}

# This will download the .tar.gz
download() {
    local BINARY_FILE=$1
    local URL=$2
    local DEST_DIR=$(pwd)
    echo "===> Downloading: " "${URL}"
    if [ -d fabric-samples ]; then
       DEST_DIR="fabric-samples"
    fi
    echo "===> Will unpack to: ${DEST_DIR}"
    curl -L --retry 5 --retry-delay 3 "${URL}" | tar xz -C "${DEST_DIR}"|| rc=$?
    if [ -n "$rc" ]; then
        echo "==> There was an error downloading the binary file."
        return 22
    else
        echo "==> Done."
    fi
}

pullBinaries() {
    echo "===> Downloading version ${FABRIC_TAG} platform specific fabric binaries"
    download "${BINARY_FILE}" "https://github.com/hyperledger/fabric/releases/download/v${VERSION}/${BINARY_FILE}"
    if [ $? -eq 22 ]; then
        echo
        echo "------> ${FABRIC_TAG} platform specific fabric binary is not available to download <----"
        echo
        exit
    fi

    echo "===> Downloading version ${CA_TAG} platform specific fabric-ca-client binary"
    download "${CA_BINARY_FILE}" "https://github.com/hyperledger/fabric-ca/releases/download/v${CA_VERSION}/${CA_BINARY_FILE}"
    if [ $? -eq 22 ]; then
        echo
        echo "------> ${CA_TAG} fabric-ca-client binary is not available to download  (Available from 1.1.0-rc1) <----"
        echo
        exit
    fi
}

pullImages() {
    command -v  ${CONTAINER_CLI}  >& /dev/null
    NODOCKER=$?
    if [ "${NODOCKER}" == 0 ]; then
        FABRIC_IMAGES=(peer orderer ccenv)
        case "$VERSION" in
        [2-3].*)
            FABRIC_IMAGES+=(baseos)
            shift
            ;;
        esac

        echo "FABRIC_IMAGES:" "${FABRIC_IMAGES[@]}"
        echo "===> Pulling fabric Images"
        singleImagePull "${FABRIC_TAG}" "${FABRIC_IMAGES[@]}"
        echo "===> Pulling fabric ca Image"
        CA_IMAGE=(ca)
        singleImagePull "${CA_TAG}" "${CA_IMAGE[@]}"
        echo "===> List out hyperledger images"
        ${CONTAINER_CLI} images | grep hyperledger
    else
        echo "========================================================="
        echo "${CONTAINER_CLI} not installed, bypassing download of Fabric images"
        echo "========================================================="
    fi
}


# Main code starts here
parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"


VERSION=$_arg_fabric_version
CA_VERSION=$_arg_ca_version

# prior to 1.2.0 architecture was determined by uname -m
if [[ $VERSION =~ ^1\.[0-1]\.* ]]; then
    export FABRIC_TAG=${MARCH}-${VERSION}
    export CA_TAG=${MARCH}-${CA_VERSION}
else
    # starting with 1.2.0, multi-arch images will be default
    : "${CA_TAG:="$CA_VERSION"}"
    : "${FABRIC_TAG:="$VERSION"}"
fi

# Prior to fabric 2.5, use amd64 binaries on darwin-arm64
if [[ $VERSION =~ ^2\.[0-4]\.* ]]; then
  PLATFORM=$(echo $PLATFORM | sed 's/darwin-arm64/darwin-amd64/g')
fi

BINARY_FILE=hyperledger-fabric-${PLATFORM}-${VERSION}.tar.gz
CA_BINARY_FILE=hyperledger-fabric-ca-${PLATFORM}-${CA_VERSION}.tar.gz

# if nothing has been specified, assume everything
if [[ ${_arg_comp[@]} =~ ^$ ]]; then
    echo "No options selected: Getting all samples, binaries, and docker images"
    echo "Abort now if not the intention"
    sleep 3 # just to give a chance to abort if this wasn't intended
    _arg_comp=('samples','binary','docker')
fi

# Process samples first then the binaries. So if the fabric-samples dir is present
# the binaries will go there
if [[ "${_arg_comp[@]}" =~ (^| |,)s(amples)? ]]; then
        echo
        echo "Clone hyperledger/fabric-samples repo"
        echo
        cloneSamplesRepo
fi

if [[ "${_arg_comp[@]}" =~ (^| |,)b(inary)? ]]; then
        echo
        echo "Pull Hyperledger Fabric binaries"
        echo
        pullBinaries
fi

if [[ "${_arg_comp[@]}" =~ (^| |,)p(odman)? ]]; then
        echo
        echo "Pull Hyperledger Fabric podman images"
        echo
        CONTAINER_CLI=podman
        pullImages
fi

if [[ "${_arg_comp[@]}" =~ (^| |,)d(ocker)? ]]; then
        echo
        echo "Pull Hyperledger Fabric docker images"
        echo
        CONTAINER_CLI=docker
        pullImages
fi



./src/path_manager.py
----------------------------------------
import os
from pathlib import Path

class PathManager:
    def __init__(self):
        # Base do projeto (assumindo que este arquivo est√° em src/)
        self.base_dir = Path(__file__).parent.parent.resolve()
        
        # Caminhos principais
        self.config_dir = self.base_dir / "config"
        self.network_dir = self.base_dir / "network"
        self.scripts_dir = self.base_dir / "scripts"
        self.templates_dir = self.base_dir / "template"
        self.versions_yaml = self.config_dir / "versions.yaml"
        
        # Arquivo de config
        self.network_yaml = self.config_dir / "network.yaml"

    def get_paths(self):
        """Retorna um dicion√°rio com todos os caminhos convertidos para string"""
        return {
            "BASE_DIR": str(self.base_dir),
            "NETWORK_DIR": str(self.network_dir),
            "SCRIPTS_DIR": str(self.scripts_dir),
            "CONFIG_FILE": str(self.network_yaml),
            "TEMPLATES_DIR": str(self.templates_dir),
        }

    def ensure_network_dirs(self):
        """Cria a estrutura de pastas dentro de network/ se n√£o existir"""
        subdirs = ["organizations", "channel-artifacts", "docker"]
        for sub in subdirs:
            (self.network_dir / sub).mkdir(parents=True, exist_ok=True)

if __name__ == "__main__":
    print("Caminhos configurados:")
    pm = PathManager()
    paths = pm.get_paths()
    for key, value in paths.items():
        print(f"{key}: {value}")


./src/colors.py
----------------------------------------
class Colors:
    RESET = "\033[0m"
    BLUE = "\033[34m"
    GREEN = "\033[32m"
    RED = "\033[31m"
    YELLOW = "\033[33m"

    def infoln(msg: str):
        print(f"{Colors.BLUE}[INFO] {msg}{Colors.RESET}")

    def successln(msg: str):
        print(f"{Colors.GREEN}[SUCESSO] {msg}{Colors.RESET}")

    def errorln(msg: str):
        print(f"{Colors.RED}[ERRO] {msg}{Colors.RESET}")

    def warnln(msg: str):
        print(f"{Colors.YELLOW}[AVISO] {msg}{Colors.RESET}")



./src/config_loader.py
----------------------------------------
# src/config_loader.py (Atualizado)
import yaml
import os
from .colors import Colors as co

class ConfigLoader:
    def __init__(self, network_config_path, versions_config_path):
        self.network_config_path = network_config_path
        self.versions_config_path = versions_config_path
        self.full_config = {}

    def load(self):
        # 1. Carrega topologia da rede
        with open(self.network_config_path, 'r') as f:
            self.full_config['network_topology'] = yaml.safe_load(f)

        # 2. Carrega vers√µes
        if os.path.exists(self.versions_config_path):
            with open(self.versions_config_path, 'r') as f:
                self.full_config['env_versions'] = yaml.safe_load(f)
        else:
            raise FileNotFoundError("Arquivo versions.yaml n√£o encontrado!")

        co.infoln("Todas as configura√ß√µes carregadas.\n")
        return self.full_config


./src/__init__.py
----------------------------------------



./src/network_controller.py
----------------------------------------
import subprocess
import os
from .colors import Colors as co

class NetworkController:
    def __init__(self, config, paths):
        self.config = config
        self.paths = paths # Inst√¢ncia do PathManager

    def _get_env_vars(self):
        """Converte as configura√ß√µes de vers√£o em vari√°veis de ambiente"""
        versions = self.config['env_versions']['versions']
        images = self.config['env_versions']['images']
        
        # Caminho absoluto para a pasta bin do projeto
        project_bin_path = os.path.join(str(self.paths.base_dir), "bin")
        
        # Pega o PATH atual do sistema
        current_path = os.environ["PATH"]

        return {
            "FABRIC_VERSION": versions['fabric'],
            "CA_VERSION": versions['fabric_ca'],
            "GO_VERSION": versions['go'],
            "DOCKER_IMAGE_PREFIX": images['org_hyperledger'],
            "PATH": f"{project_bin_path}:{current_path}"
        }

    def run_script(self, script_name, extra_env=None):
        script_path = os.path.join(self.paths.scripts_dir, script_name)
        
        # 1. Carrega vari√°veis base do sistema
        env = os.environ.copy()
        
        # 2. Injeta vari√°veis de vers√£o (Carregadas do YAML)
        env.update(self._get_env_vars())
        
        # 3. Injeta o caminho da pasta network (Do PathManager)
        env["NETWORK_DIR"] = str(self.paths.network_dir)

        # 4. Injeta vari√°veis extras espec√≠ficas da chamada
        if extra_env:
            env.update(extra_env)

        co.infoln(f"Executando {script_name} (Fabric v{env['FABRIC_VERSION']})...")
        
        subprocess.run(["bash", script_path], check=True, env=env)

    def prepare_environment(self):
        # Cria as pastas necess√°rias
        self.paths.ensure_network_dirs()
        # Poderia chamar um script de limpeza aqui tamb√©m
        # self._run_script("00_cleanup.sh")


./config/configtx.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

################################################################################
#
#   NOTE
#
#   Since release V3.0 Solo, Kafka and the System Channel have been removed
#   and are no longer supported.
#
################################################################################

---
################################################################################
#
#   ORGANIZATIONS
#
#   This section defines the organizational identities that can be referenced
#   in the configuration profiles.
#
################################################################################
Organizations:
  # SampleOrg defines an MSP using the sampleconfig. It should never be used
  # in production but may be used as a template for other definitions.
  - &SampleOrg
    # Name is the key by which this org will be referenced in channel
    # configuration transactions.
    # Name can include alphanumeric characters as well as dots and dashes.
    Name: SampleOrg

    # SkipAsForeign can be set to true for org definitions which are to be
    # inherited from the orderer system channel during channel creation.  This
    # is especially useful when an admin of a single org without access to the
    # MSP directories of the other orgs wishes to create a channel.  Note
    # this property must always be set to false for orgs included in block
    # creation.
    SkipAsForeign: false

    # ID is the key by which this org's MSP definition will be referenced.
    # ID can include alphanumeric characters as well as dots and dashes.
    ID: SampleOrg

    # MSPDir is the filesystem path which contains the MSP configuration.
    MSPDir: msp

    # Policies defines the set of policies at this level of the config tree
    # For organization policies, their canonical path is usually
    #   /Channel/<Application|Orderer>/<OrgName>/<PolicyName>
    Policies: &SampleOrgPolicies
      Readers:
        Type: Signature
        Rule: "OR('SampleOrg.member')"
        # If your MSP is configured with the new NodeOUs, you might
        # want to use a more specific rule like the following:
        # Rule: "OR('SampleOrg.admin', 'SampleOrg.peer', 'SampleOrg.client')"
      Writers:
        Type: Signature
        Rule: "OR('SampleOrg.member')"
        # If your MSP is configured with the new NodeOUs, you might
        # want to use a more specific rule like the following:
        # Rule: "OR('SampleOrg.admin', 'SampleOrg.client')"
      Admins:
        Type: Signature
        Rule: "OR('SampleOrg.admin')"
      Endorsement:
        Type: Signature
        Rule: "OR('SampleOrg.member')"

    # OrdererEndpoints is a list of all orderers this org runs which clients
    # and peers may to connect to push transactions and receive blocks respectively.
    OrdererEndpoints:
      - "127.0.0.1:7050"

################################################################################
#
#   CAPABILITIES
#
#   This section defines the capabilities of fabric network. This is a new
#   concept as of v1.1.0 and should not be utilized in mixed networks with
#   v1.0.x peers and orderers.  Capabilities define features which must be
#   present in a fabric binary for that binary to safely participate in the
#   fabric network.  For instance, if a new MSP type is added, newer binaries
#   might recognize and validate the signatures from this type, while older
#   binaries without this support would be unable to validate those
#   transactions.  This could lead to different versions of the fabric binaries
#   having different world states.  Instead, defining a capability for a channel
#   informs those binaries without this capability that they must cease
#   processing transactions until they have been upgraded.  For v1.0.x if any
#   capabilities are defined (including a map with all capabilities turned off)
#   then the v1.0.x peer will deliberately crash.
#
################################################################################
Capabilities:
  # Channel capabilities apply to both the orderers and the peers and must be
  # supported by both.
  # Set the value of the capability to true to require it.
  Channel: &ChannelCapabilities
    # V3.0 for Channel is a catchall flag for behavior which has been
    # determined to be desired for all orderers and peers running at the v3.0.0
    # level, but which would be incompatible with orderers and peers from
    # prior releases.
    # Prior to enabling V3.0 channel capabilities, ensure that all
    # orderers and peers on a channel are at v3.0.0 or later.
    V3_0: true

  # Orderer capabilities apply only to the orderers, and may be safely
  # used with prior release peers.
  # Set the value of the capability to true to require it.
  Orderer: &OrdererCapabilities
    # V1.1 for Orderer is a catchall flag for behavior which has been
    # determined to be desired for all orderers running at the v1.1.x
    # level, but which would be incompatible with orderers from prior releases.
    # Prior to enabling V2.0 orderer capabilities, ensure that all
    # orderers on a channel are at v2.0.0 or later.
    V2_0: true

  # Application capabilities apply only to the peer network, and may be safely
  # used with prior release orderers.
  # Set the value of the capability to true to require it.
  Application: &ApplicationCapabilities
    # V2.5 for Application enables the new non-backwards compatible
    # features of fabric v2.5, namely the ability to purge private data.
    # Prior to enabling V2.5 application capabilities, ensure that all
    # peers on a channel are at v2.5.0 or later.
    V2_5: true

################################################################################
#
#   APPLICATION
#
#   This section defines the values to encode into a config transaction or
#   genesis block for application-related parameters.
#
################################################################################
Application: &ApplicationDefaults
  ACLs: &ACLsDefault
    # This section provides defaults for policies for various resources
    # in the system. These "resources" could be functions on system chaincodes
    # (e.g., "GetBlockByNumber" on the "qscc" system chaincode) or other resources
    # (e.g.,who can receive Block events). This section does NOT specify the resource's
    # definition or API, but just the ACL policy for it.
    #
    # Users can override these defaults with their own policy mapping by defining the
    # mapping under ACLs in their channel definition

    #---New Lifecycle System Chaincode (_lifecycle) function to policy mapping for access control--#

    # ACL policy for _lifecycle's "CheckCommitReadiness" function
    _lifecycle/CheckCommitReadiness: /Channel/Application/Writers

    # ACL policy for _lifecycle's "CommitChaincodeDefinition" function
    _lifecycle/CommitChaincodeDefinition: /Channel/Application/Writers

    # ACL policy for _lifecycle's "QueryChaincodeDefinition" function
    _lifecycle/QueryChaincodeDefinition: /Channel/Application/Writers

    # ACL policy for _lifecycle's "QueryChaincodeDefinitions" function
    _lifecycle/QueryChaincodeDefinitions: /Channel/Application/Writers

    #---Lifecycle System Chaincode (lscc) function to policy mapping for access control---#

    # ACL policy for lscc's "getid" function
    lscc/ChaincodeExists: /Channel/Application/Readers

    # ACL policy for lscc's "getdepspec" function
    lscc/GetDeploymentSpec: /Channel/Application/Readers

    # ACL policy for lscc's "getccdata" function
    lscc/GetChaincodeData: /Channel/Application/Readers

    # ACL Policy for lscc's "getchaincodes" function
    lscc/GetInstantiatedChaincodes: /Channel/Application/Readers

    #---Query System Chaincode (qscc) function to policy mapping for access control---#

    # ACL policy for qscc's "GetChainInfo" function
    qscc/GetChainInfo: /Channel/Application/Readers

    # ACL policy for qscc's "GetBlockByNumber" function
    qscc/GetBlockByNumber: /Channel/Application/Readers

    # ACL policy for qscc's  "GetBlockByHash" function
    qscc/GetBlockByHash: /Channel/Application/Readers

    # ACL policy for qscc's "GetTransactionByID" function
    qscc/GetTransactionByID: /Channel/Application/Readers

    # ACL policy for qscc's "GetBlockByTxID" function
    qscc/GetBlockByTxID: /Channel/Application/Readers

    #---Configuration System Chaincode (cscc) function to policy mapping for access control---#

    # ACL policy for cscc's "GetConfigBlock" function
    cscc/GetConfigBlock: /Channel/Application/Readers

    # ACL policy for cscc's "GetChannelConfig" function
    cscc/GetChannelConfig: /Channel/Application/Readers

    #---Miscellaneous peer function to policy mapping for access control---#

    # ACL policy for invoking chaincodes on peer
    peer/Propose: /Channel/Application/Writers

    # ACL policy for chaincode to chaincode invocation
    peer/ChaincodeToChaincode: /Channel/Application/Writers

    #---Events resource to policy mapping for access control###---#

    # ACL policy for sending block events
    event/Block: /Channel/Application/Readers

    # ACL policy for sending filtered block events
    event/FilteredBlock: /Channel/Application/Readers

  # Organizations lists the orgs participating on the application side of the
  # network.
  Organizations:

  # Policies defines the set of policies at this level of the config tree
  # For Application policies, their canonical path is
  #   /Channel/Application/<PolicyName>
  Policies: &ApplicationDefaultPolicies
    LifecycleEndorsement:
      Type: ImplicitMeta
      Rule: "MAJORITY Endorsement"
    Endorsement:
      Type: ImplicitMeta
      Rule: "MAJORITY Endorsement"
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"

  # Capabilities describes the application level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *ApplicationCapabilities

################################################################################
#
#   ORDERER
#
#   This section defines the values to encode into a config transaction or
#   genesis block for orderer related parameters.
#
################################################################################
Orderer: &OrdererDefaults
  # Orderer Type: The orderer implementation to start.
  # Available types are "etcdraft" and "BFT".
  # Please note that "solo" and "kafka" are no longer supported.
  OrdererType: etcdraft

  # Addresses used to be the list of orderer addresses that clients and peers
  # could connect to.  However, this does not allow clients to associate orderer
  # addresses and orderer organizations which can be useful for things such
  # as TLS validation.  The preferred way to specify orderer addresses is now
  # to include the OrdererEndpoints item in your org definition
  Addresses:
    # - 127.0.0.1:7050

  # Batch Timeout: The amount of time to wait before creating a batch.
  BatchTimeout: 2s

  # Batch Size: Controls the number of messages batched into a block.
  # The orderer views messages opaquely, but typically, messages may
  # be considered to be Fabric transactions.  The 'batch' is the group
  # of messages in the 'data' field of the block.  Blocks will be a few kb
  # larger than the batch size, when signatures, hashes, and other metadata
  # is applied.
  BatchSize:
    # Max Message Count: The maximum number of messages to permit in a
    # batch.  No block will contain more than this number of messages.
    MaxMessageCount: 500

    # Absolute Max Bytes: The absolute maximum number of bytes allowed for
    # the serialized messages in a batch. The maximum block size is this value
    # plus the size of the associated metadata (usually a few KB depending
    # upon the size of the signing identities). Any transaction larger than
    # this value will be rejected by ordering.
    # It is recommended not to exceed 49 MB, given the default grpc max message size of 100 MB
    # configured on orderer and peer nodes (and allowing for message expansion during communication).
    AbsoluteMaxBytes: 10 MB

    # Preferred Max Bytes: The preferred maximum number of bytes allowed
    # for the serialized messages in a batch. Roughly, this field may be considered
    # the best effort maximum size of a batch. A batch will fill with messages
    # until this size is reached (or the max message count, or batch timeout is
    # exceeded).  If adding a new message to the batch would cause the batch to
    # exceed the preferred max bytes, then the current batch is closed and written
    # to a block, and a new batch containing the new message is created.  If a
    # message larger than the preferred max bytes is received, then its batch
    # will contain only that message.  Because messages may be larger than
    # preferred max bytes (up to AbsoluteMaxBytes), some batches may exceed
    # the preferred max bytes, but will always contain exactly one transaction.
    PreferredMaxBytes: 2 MB

  # Max Channels is the maximum number of channels to allow on the ordering
  # network. When set to 0, this implies no maximum number of channels.
  MaxChannels: 0

  # ConsenterMapping contains the definition of consenter identity, endpoints, and crypto material.
  # The ConsenterMapping is used in the BFT consensus protocol, and should include enough servers to ensure
  # fault-tolerance; In BFT this number is at least 3*F+1, where F is the number of potential failures.
  # In BFT it is highly recommended that the addresses for delivery & broadcast (the OrdererEndpoints item in the
  # org definition) map 1:1 to the Orderer/ConsenterMapping (for cluster consensus). That is, every consenter should
  # be represented by a delivery endpoint. Note that in BFT (V3) global Orderer/Addresses are no longer supported.
  ConsenterMapping:
    - ID: 1
      Host: bft0.example.com
      Port: 7050
      MSPID: OrdererOrg1
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert0
      ServerTLSCert: path/to/ServerTLSCert0
    - ID: 2
      Host: bft1.example.com
      Port: 7050
      MSPID: OrdererOrg2
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert1
      ServerTLSCert: path/to/ServerTLSCert1
    - ID: 3
      Host: bft2.example.com
      Port: 7050
      MSPID: OrdererOrg3
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert2
      ServerTLSCert: path/to/ServerTLSCert2
    - ID: 4
      Host: bft3.example.com
      Port: 7050
      MSPID: OrdererOrg4
      Identity: /path/to/identity
      ClientTLSCert: path/to/ClientTLSCert3
      ServerTLSCert: path/to/ServerTLSCert3

  # EtcdRaft defines configuration which must be set when the "etcdraft"
  # orderertype is chosen.
  EtcdRaft:
    # The set of Raft replicas for this network. For the etcd/raft-based
    # implementation, we expect every replica to also be an OSN. Therefore,
    # a subset of the host:port items enumerated in this list should be
    # replicated under the Orderer.Addresses key above.
    Consenters:
      - Host: raft0.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert0
        ServerTLSCert: path/to/ServerTLSCert0
      - Host: raft1.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert1
        ServerTLSCert: path/to/ServerTLSCert1
      - Host: raft2.example.com
        Port: 7050
        ClientTLSCert: path/to/ClientTLSCert2
        ServerTLSCert: path/to/ServerTLSCert2

    # Options to be specified for all the etcd/raft nodes. The values here
    # are the defaults for all new channels and can be modified on a
    # per-channel basis via configuration updates.
    Options:
      # TickInterval is the time interval between two Node.Tick invocations.
      TickInterval: 500ms

      # ElectionTick is the number of Node.Tick invocations that must pass
      # between elections. That is, if a follower does not receive any
      # message from the leader of current term before ElectionTick has
      # elapsed, it will become candidate and start an election.
      # ElectionTick must be greater than HeartbeatTick.
      ElectionTick: 10

      # HeartbeatTick is the number of Node.Tick invocations that must
      # pass between heartbeats. That is, a leader sends heartbeat
      # messages to maintain its leadership every HeartbeatTick ticks.
      HeartbeatTick: 1

      # MaxInflightBlocks limits the max number of in-flight append messages
      # during optimistic replication phase.
      MaxInflightBlocks: 5

      # SnapshotIntervalSize defines number of bytes per which a snapshot is taken
      SnapshotIntervalSize: 16 MB

  # Organizations lists the orgs participating on the orderer side of the
  # network.
  Organizations:

  # Policies defines the set of policies at this level of the config tree
  # For Orderer policies, their canonical path is
  #   /Channel/Orderer/<PolicyName>
  Policies:
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"
    # BlockValidation specifies what signatures must be included in the block
    # from the orderer for the peer to validate it.
    BlockValidation:
      Type: ImplicitMeta
      Rule: "ANY Writers"

  # Capabilities describes the orderer level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *OrdererCapabilities

################################################################################
#
#   CHANNEL
#
#   This section defines the values to encode into a config transaction or
#   genesis block for channel related parameters.
#
################################################################################
Channel: &ChannelDefaults
  # Policies defines the set of policies at this level of the config tree
  # For Channel policies, their canonical path is
  #   /Channel/<PolicyName>
  Policies:
    # Who may invoke the 'Deliver' API
    Readers:
      Type: ImplicitMeta
      Rule: "ANY Readers"
    # Who may invoke the 'Broadcast' API
    Writers:
      Type: ImplicitMeta
      Rule: "ANY Writers"
    # By default, who may modify elements at this config level
    Admins:
      Type: ImplicitMeta
      Rule: "MAJORITY Admins"

  # Capabilities describes the channel level capabilities, see the
  # dedicated Capabilities section elsewhere in this file for a full
  # description
  Capabilities:
    <<: *ChannelCapabilities

################################################################################
#
#   PROFILES
#
#   Different configuration profiles may be encoded here to be specified as
#   parameters to the configtxgen tool. The profiles which specify consortiums
#   are to be used for generating the orderer genesis block. With the correct
#   consortium members defined in the orderer genesis block, channel creation
#   requests may be generated with only the org member names and a consortium
#   name.
#
################################################################################
Profiles:
  # SampleSingleMSPSolo defines a configuration which uses the Solo orderer,
  # and contains a single MSP definition (the MSP sampleconfig).
  # The Consortium SampleConsortium has only a single member, SampleOrg.
  SampleSingleMSPSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
      Organizations:
        - *SampleOrg
    Consortiums:
      SampleConsortium:
        Organizations:
          - *SampleOrg

  # SampleInsecureSolo defines a configuration which uses the Solo orderer,
  # contains no MSP definitions, and allows all transactions and channel
  # creation requests for the consortium SampleConsortium.
  SampleInsecureSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
    Consortiums:
      SampleConsortium:
        Organizations:

  # SampleDevModeSolo defines a configuration which uses the Solo orderer,
  # contains the sample MSP as both orderer and consortium member, and
  # requires only basic membership for admin privileges. It also defines
  # an Application on the ordering system channel, which should usually
  # be avoided.
  SampleDevModeSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Consortiums:
      SampleConsortium:
        Organizations:
          - <<: *SampleOrg
            Policies:
              <<: *SampleOrgPolicies
              Admins:
                Type: Signature
                Rule: "OR('SampleOrg.member')"


  # SampleSingleMSPChannel defines a channel with only the sample org as a
  # member. It is designed to be used in conjunction with SampleSingleMSPSolo
  # orderer profile. Note, for channel creation profiles, only the
  # 'Application' section and consortium # name are considered.
  SampleSingleMSPChannel:
    <<: *ChannelDefaults
    Consortium: SampleConsortium
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg

  # SampleDevModeEtcdRaft defines a configuration that differs from the
  # SampleDevModeSolo one only in that it uses the etcd/raft-based orderer.
  SampleDevModeEtcdRaft:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Consortiums:
      SampleConsortium:
        Organizations:
          - <<: *SampleOrg
            Policies:
              <<: *SampleOrgPolicies
              Admins:
                Type: Signature
                Rule: "OR('SampleOrg.member')"

  # SampleAppChannelInsecureSolo defines an application channel configuration
  # which uses the Solo orderer and contains no MSP definitions.
  SampleAppChannelInsecureSolo:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      OrdererType: solo
    Application:
      <<: *ApplicationDefaults

  # SampleAppChannelEtcdRaft defines an application channel configuration
  # that uses the etcd/raft-based orderer.
  SampleAppChannelEtcdRaft:
    <<: *ChannelDefaults
    Orderer:
      <<: *OrdererDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
          OrdererEndpoints:
            - "127.0.0.1:7050"
            - "127.0.0.1:7051"
            - "127.0.0.1:7052"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"

  # SampleAppChannelSmartBft defines an application channel configuration
  # that uses the Smart BFT orderer.
  SampleAppChannelSmartBft:
    <<: *ChannelDefaults
    Consortium: SampleConsortium
    Orderer:
      <<: *OrdererDefaults
      OrdererType: BFT
      BatchSize:
        MaxMessageCount: 5000
        AbsoluteMaxBytes: 10 MB
      SmartBFT:
        RequestBatchMaxInterval: 200ms
        RequestForwardTimeout: 5s
        RequestComplainTimeout: 20s
        RequestAutoRemoveTimeout: 3m0s
        ViewChangeResendInterval: 5s
        ViewChangeTimeout: 20s
        LeaderHeartbeatTimeout: 1m0s
        CollectTimeout: 1s
        IncomingMessageBufferSize: 200
        RequestPoolSize: 100000
        LeaderHeartbeatCount: 10
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"
    Application:
      <<: *ApplicationDefaults
      Organizations:
        - <<: *SampleOrg
          Policies:
            <<: *SampleOrgPolicies
            Admins:
              Type: Signature
              Rule: "OR('SampleOrg.member')"



./config/core.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

###############################################################################
#
#    Peer section
#
###############################################################################
peer:
  # The peer id provides a name for this peer instance and is used when
  # naming docker resources.
  id: jdoe

  # The networkId allows for logical separation of networks and is used when
  # naming docker resources.
  networkId: dev

  # The Address at local network interface this Peer will listen on.
  # By default, it will listen on all network interfaces
  listenAddress: 0.0.0.0:7051

  # The endpoint this peer uses to listen for inbound chaincode connections.
  # If this is commented-out, the listen address is selected to be
  # the peer's address (see below) with port 7052
  # chaincodeListenAddress: 0.0.0.0:7052

  # The endpoint the chaincode for this peer uses to connect to the peer.
  # If this is not specified, the chaincodeListenAddress address is selected.
  # And if chaincodeListenAddress is not specified, address is selected from
  # peer address (see below). If specified peer address is invalid then it
  # will fallback to the auto detected IP (local IP) regardless of the peer
  # addressAutoDetect value.
  # chaincodeAddress: 0.0.0.0:7052

  # When used as peer config, this represents the endpoint to other peers
  # in the same organization. For peers in other organization, see
  # gossip.externalEndpoint for more info.
  # When used as CLI config, this means the peer's endpoint to interact with
  address: 0.0.0.0:7051

  # Whether the Peer should programmatically determine its address
  # This case is useful for docker containers.
  # When set to true, will override peer address.
  addressAutoDetect: false

  # Settings for the Peer's gateway server.
  gateway:
    # Whether the gateway is enabled for this Peer.
    enabled: true
    # endorsementTimeout is the duration the gateway waits for a response
    # from other endorsing peers before returning a timeout error to the client.
    endorsementTimeout: 30s
    # broadcastTimeout is the duration the gateway waits for a response
    # from ordering nodes before returning a timeout error to the client.
    broadcastTimeout: 30s
    # dialTimeout is the duration the gateway waits for a connection
    # to other network nodes.
    dialTimeout: 2m

  # Keepalive settings for peer server and clients
  keepalive:
    # Interval is the duration after which if the server does not see
    # any activity from the client it pings the client to see if it's alive
    interval: 7200s
    # Timeout is the duration the server waits for a response
    # from the client after sending a ping before closing the connection
    timeout: 20s
    # MinInterval is the minimum permitted time between client pings.
    # If clients send pings more frequently, the peer server will
    # disconnect them
    minInterval: 60s
    # Client keepalive settings for communicating with other peer nodes
    client:
      # Interval is the time between pings to peer nodes.  This must
      # greater than or equal to the minInterval specified by peer
      # nodes
      interval: 60s
      # Timeout is the duration the client waits for a response from
      # peer nodes before closing the connection
      timeout: 20s
    # DeliveryClient keepalive settings for communication with ordering
    # nodes.
    deliveryClient:
      # Interval is the time between pings to ordering nodes.  This must
      # greater than or equal to the minInterval specified by ordering
      # nodes.
      interval: 60s
      # Timeout is the duration the client waits for a response from
      # ordering nodes before closing the connection
      timeout: 20s

  # Gossip related configuration
  gossip:
    # Bootstrap set to initialize gossip with.
    # This is a list of other peers that this peer reaches out to at startup.
    # Important: The endpoints here have to be endpoints of peers in the same
    # organization, because the peer would refuse connecting to these endpoints
    # unless they are in the same organization as the peer.
    bootstrap: 127.0.0.1:7051

    # NOTE: orgLeader and useLeaderElection parameters are mutual exclusive.
    # Setting both to true would result in the termination of the peer
    # since this is undefined state. If the peers are configured with
    # useLeaderElection=false, make sure there is at least 1 peer in the
    # organization that its orgLeader is set to true.

    # Defines whenever peer will initialize dynamic algorithm for
    # "leader" selection, where leader is the peer to establish
    # connection with ordering service and use delivery protocol
    # to pull ledger blocks from ordering service.
    useLeaderElection: false
    # Statically defines peer to be an organization "leader".
    # Organization leaders maintain connection with ordering service
    # and pulls blocks as they are created. Optionally, leader peers
    # may disseminate pulled blocks to peers in its own organization
    # based on the peer.deliveryclient.blockGossipEnabled setting below.
    # Multiple peers or all peers in an organization
    # may be configured as org leaders, so that they all pull
    # blocks directly from ordering service.
    orgLeader: true

    # Interval for membershipTracker polling
    membershipTrackerInterval: 5s

    # Overrides the endpoint that the peer publishes to peers
    # in its organization. For peers in foreign organizations
    # see 'externalEndpoint'
    endpoint:
    # Maximum count of blocks stored in memory
    maxBlockCountToStore: 10
    # Max time between consecutive message pushes(unit: millisecond)
    maxPropagationBurstLatency: 10ms
    # Max number of messages stored until a push is triggered to remote peers
    maxPropagationBurstSize: 10
    # Number of times a message is pushed to remote peers
    propagateIterations: 1
    # Number of peers selected to push messages to
    propagatePeerNum: 3
    # Determines frequency of pull phases(unit: second)
    # Must be greater than digestWaitTime + responseWaitTime
    pullInterval: 4s
    # Number of peers to pull from
    pullPeerNum: 3
    # Determines frequency of pulling state info messages from peers(unit: second)
    requestStateInfoInterval: 4s
    # Determines frequency of pushing state info messages to peers(unit: second)
    publishStateInfoInterval: 4s
    # Maximum time a stateInfo message is kept until expired
    stateInfoRetentionInterval:
    # Time from startup certificates are included in Alive messages(unit: second)
    publishCertPeriod: 10s
    # Should we skip verifying block messages or not (currently not in use)
    skipBlockVerification: false
    # Dial timeout(unit: second)
    dialTimeout: 3s
    # Connection timeout(unit: second)
    connTimeout: 2s
    # Buffer size of received messages
    recvBuffSize: 20
    # Buffer size of sending messages
    sendBuffSize: 200
    # Time to wait before pull engine processes incoming digests (unit: second)
    # Should be slightly smaller than requestWaitTime
    digestWaitTime: 1s
    # Time to wait before pull engine removes incoming nonce (unit: milliseconds)
    # Should be slightly bigger than digestWaitTime
    requestWaitTime: 1500ms
    # Time to wait before pull engine ends pull (unit: second)
    responseWaitTime: 2s
    # Alive check interval(unit: second)
    aliveTimeInterval: 5s
    # Alive expiration timeout(unit: second)
    aliveExpirationTimeout: 25s
    # Reconnect interval(unit: second)
    reconnectInterval: 25s
    # Max number of attempts to connect to a peer
    maxConnectionAttempts: 120
    # Message expiration factor for alive messages
    msgExpirationFactor: 20
    # This is an endpoint that is published to peers outside of the organization.
    # If this isn't set, the peer will not be known to other organizations and will not be exposed via service discovery.
    externalEndpoint:
    # Leader election service configuration
    election:
      # Longest time peer waits for stable membership during leader election startup (unit: second)
      startupGracePeriod: 15s
      # Interval gossip membership samples to check its stability (unit: second)
      membershipSampleInterval: 1s
      # Time passes since last declaration message before peer decides to perform leader election (unit: second)
      leaderAliveThreshold: 10s
      # Time between peer sends propose message and declares itself as a leader (sends declaration message) (unit: second)
      leaderElectionDuration: 5s

    pvtData:
      # pullRetryThreshold determines the maximum duration of time private data corresponding for a given block
      # would be attempted to be pulled from peers until the block would be committed without the private data
      pullRetryThreshold: 60s
      # As private data enters the transient store, it is associated with the peer's ledger's height at that time.
      # transientstoreMaxBlockRetention defines the maximum difference between the current ledger's height upon commit,
      # and the private data residing inside the transient store that is guaranteed not to be purged.
      # Private data is purged from the transient store when blocks with sequences that are multiples
      # of transientstoreMaxBlockRetention are committed.
      transientstoreMaxBlockRetention: 20000
      # pushAckTimeout is the maximum time to wait for an acknowledgement from each peer
      # at private data push at endorsement time.
      pushAckTimeout: 3s
      # Block to live pulling margin, used as a buffer
      # to prevent peer from trying to pull private data
      # from peers that is soon to be purged in next N blocks.
      # This helps a newly joined peer catch up to current
      # blockchain height quicker.
      btlPullMargin: 10
      # the process of reconciliation is done in an endless loop, while in each iteration reconciler tries to
      # pull from the other peers the most recent missing blocks with a maximum batch size limitation.
      # reconcileBatchSize determines the maximum batch size of missing private data that will be reconciled in a
      # single iteration.
      reconcileBatchSize: 10
      # reconcileSleepInterval determines the time reconciler sleeps from end of an iteration until the beginning
      # of the next reconciliation iteration.
      reconcileSleepInterval: 1m
      # reconciliationEnabled is a flag that indicates whether private data reconciliation is enable or not.
      reconciliationEnabled: true
      # skipPullingInvalidTransactionsDuringCommit is a flag that indicates whether pulling of invalid
      # transaction's private data from other peers need to be skipped during the commit time and pulled
      # only through reconciler.
      skipPullingInvalidTransactionsDuringCommit: false
      # implicitCollectionDisseminationPolicy specifies the dissemination  policy for the peer's own implicit collection.
      # When a peer endorses a proposal that writes to its own implicit collection, below values override the default values
      # for disseminating private data.
      # Note that it is applicable to all channels the peer has joined. The implication is that requiredPeerCount has to
      # be smaller than the number of peers in a channel that has the lowest numbers of peers from the organization.
      implicitCollectionDisseminationPolicy:
        # requiredPeerCount defines the minimum number of eligible peers to which the peer must successfully
        # disseminate private data for its own implicit collection during endorsement. Default value is 0.
        requiredPeerCount: 0
        # maxPeerCount defines the maximum number of eligible peers to which the peer will attempt to
        # disseminate private data for its own implicit collection during endorsement. Default value is 1.
        maxPeerCount: 1

    # Gossip state transfer related configuration
    state:
      # Indicates whether state transfer is enabled.
      # State transfer enabled allows a peer that is not a leader
      # to sync up missed blocks from other peers.
      # Default value is false since the recommended value of peer.gossip.orgleader is true.
      # Keep in mind that when peer.gossip.useLeaderElection is true
      # and there are several peers in the organization,
      # or peer.gossip.useLeaderElection is false alongside with
      # peer.gossip.orgleader being false, the peer's ledger may lag behind
      # the rest of the peers and will never catch up due to state transfer
      # being disabled.
      enabled: false
      # checkInterval interval to check whether peer is lagging behind enough to
      # request blocks via state transfer from another peer.
      checkInterval: 10s
      # responseTimeout amount of time to wait for state transfer response from
      # other peers
      responseTimeout: 3s
      # batchSize the number of blocks to request via state transfer from another peer
      batchSize: 10
      # blockBufferSize reflects the size of the re-ordering buffer
      # which captures blocks and takes care to deliver them in order
      # down to the ledger layer. The actual buffer size is bounded between
      # 0 and 2*blockBufferSize, each channel maintains its own buffer
      blockBufferSize: 20
      # maxRetries maximum number of re-tries to ask
      # for single state transfer request
      maxRetries: 3

  # TLS Settings
  tls:
    # Require server-side TLS
    enabled: false
    # Require client certificates / mutual TLS for inbound connections.
    # Note that clients that are not configured to use a certificate will
    # fail to connect to the peer.
    clientAuthRequired: false
    # X.509 certificate used for TLS server
    cert:
      file: tls/server.crt
    # Private key used for TLS server
    key:
      file: tls/server.key
    # rootcert.file represents the trusted root certificate chain used for verifying certificates
    # of other nodes during outbound connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    rootcert:
      file: tls/ca.crt
    # If mutual TLS is enabled, clientRootCAs.files contains a list of additional root certificates
    # used for verifying certificates of client connections.
    # It augments the set of TLS CA certificates available from the MSPs of each channel‚Äôs configuration.
    # Minimally, set your organization's TLS CA root certificate so that the peer can receive join channel requests.
    clientRootCAs:
      files:
        - tls/ca.crt
    # Private key used for TLS when making client connections.
    # If not set, peer.tls.key.file will be used instead
    clientKey:
      file:
    # X.509 certificate used for TLS when making client connections.
    # If not set, peer.tls.cert.file will be used instead
    clientCert:
      file:

  # Authentication contains configuration parameters related to authenticating
  # client messages
  authentication:
    # the acceptable difference between the current server time and the
    # client's time as specified in a client request message
    # this value is used for delivery service and
    # endorsement service (if the authFilter is enabled)
    timewindow: 15m

  # Path on the file system where peer will store data (eg ledger). This
  # location must be access control protected to prevent unintended
  # modification that might corrupt the peer operations.
  # The path may be relative to FABRIC_CFG_PATH or an absolute path.
  fileSystemPath: /var/hyperledger/production

  # BCCSP (Blockchain crypto provider): Select which crypto implementation or
  # library to use
  BCCSP:
    Default: SW
    # Settings for the SW crypto provider (i.e. when DEFAULT: SW)
    SW:
      # TODO: The default Hash and Security level needs refactoring to be
      # fully configurable. Changing these defaults requires coordination
      # SHA2 is hardcoded in several places, not only BCCSP
      Hash: SHA2
      Security: 256
      # Location of Key Store
      FileKeyStore:
        # If "", defaults to 'mspConfigPath'/keystore
        KeyStore:
    # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)
    PKCS11:
      # Location of the PKCS11 module library
      Library:
      # Token Label
      Label:
      # User PIN
      Pin:
      Hash:
      Security:
      SoftwareVerify:
      Immutable:
      AltID:
      KeyIds:

  # Path on the file system where peer will find MSP local configurations
  # The path may be relative to FABRIC_CFG_PATH or an absolute path.
  mspConfigPath: msp

  # Identifier of the local MSP
  # ----!!!!IMPORTANT!!!-!!!IMPORTANT!!!-!!!IMPORTANT!!!!----
  # Deployers need to change the value of the localMspId string.
  # In particular, the name of the local MSP ID of a peer needs
  # to match the name of one of the MSPs in each of the channel
  # that this peer is a member of. Otherwise this peer's messages
  # will not be identified as valid by other nodes.
  localMspId: SampleOrg

  # CLI common client config options
  client:
    # connection timeout
    connTimeout: 3s

  # Delivery service related config
  deliveryclient:
    # Enables this peer to disseminate blocks it pulls from the ordering service
    # to other peers in the same organization via gossip.
    # Note that 'gossip.state.enabled' controls point to point block replication
    # of blocks committed in the past.
    blockGossipEnabled: false
    # It sets the total time the delivery service may spend in reconnection
    # attempts until its retry logic gives up and returns an error,
    # ignored if peer is a static leader
    reconnectTotalTimeThreshold: 3600s

    # It sets the delivery service <-> ordering service node connection timeout
    connTimeout: 3s

    # It sets the delivery service maximal delay between consecutive retries.
    # Time between retries will have exponential backoff until hitting this threshold.
    reConnectBackoffThreshold: 3600s

    # If a certain header from a header receiver is in front of the block receiver for more that this time, a
    # censorship event is declared and the block source is changed.
    blockCensorshipTimeoutKey: 30s

    # The initial value of the actual retry interval, which is increased on every failed retry
    minimalReconnectInterval: 100ms

    # A list of orderer endpoint addresses which should be overridden
    # when found in channel configurations.
    addressOverrides:
      # - from:
      #   to:
      #   caCertsFile:
      # - from:
      #   to:
      #   caCertsFile:

    # Determines which delivery client will be used when consensus type is "BFT"
    # (when consensus type is "etcdraft" this key is ignored).
    # "simple" - use CFT deliverer
    # "cluster" - use BFT deliverer
    policy: cluster

  # Type for the local MSP - by default it's of type bccsp
  localMspType: bccsp

  # Used with Go profiling tools only in none production environment. In
  # production, it should be disabled (eg enabled: false)
  profile:
    enabled: false
    listenAddress: 0.0.0.0:6060

  # Handlers defines custom handlers that can filter and mutate
  # objects passing within the peer, such as:
  #   Auth filter - reject or forward proposals from clients
  #   Decorators  - append or mutate the chaincode input passed to the chaincode
  #   Endorsers   - Custom signing over proposal response payload and its mutation
  # Valid handler definition contains:
  #   - A name which is a factory method name defined in
  #     core/handlers/library/library.go for statically compiled handlers
  #   - library path to shared object binary for pluggable filters
  # Auth filters and decorators are chained and executed in the order that
  # they are defined. For example:
  # authFilters:
  #   - name: FilterOne
  #     library: /opt/lib/filter.so
  #   - name: FilterTwo
  # decorators:
  #   - name: DecoratorOne
  #   - name: DecoratorTwo
  #     library: /opt/lib/decorator.so
  # Endorsers are configured as a map that its keys are the endorsement system chaincodes that are being overridden.
  # Below is an example that overrides the default ESCC and uses an endorsement plugin that has the same functionality
  # as the default ESCC.
  # If the 'library' property is missing, the name is used as the constructor method in the builtin library similar
  # to auth filters and decorators.
  # endorsers:
  #   escc:
  #     name: DefaultESCC
  #     library: /etc/hyperledger/fabric/plugin/escc.so
  handlers:
    authFilters:
      - name: DefaultAuth
      - name: ExpirationCheck # This filter checks identity x509 certificate expiration
      - name: TimeWindowCheck # This filter checks the timestamp of an proposal request with the peer.authentication.timewindow parameter from core.yaml
    decorators:
      - name: DefaultDecorator
    endorsers:
      escc:
        name: DefaultEndorsement
        library:
    validators:
      vscc:
        name: DefaultValidation
        library:

        # library: /etc/hyperledger/fabric/plugin/escc.so
  # Number of goroutines that will execute transaction validation in parallel.
  # By default, the peer chooses the number of CPUs on the machine. Set this
  # variable to override that choice.
  # NOTE: overriding this value might negatively influence the performance of
  # the peer so please change this value only if you know what you're doing
  validatorPoolSize:

  # The discovery service is used by clients to query information about peers,
  # such as - which peers have joined a certain channel, what is the latest
  # channel config, and most importantly - given a chaincode and a channel,
  # what possible sets of peers satisfy the endorsement policy.
  discovery:
    enabled: true
    # Whether the authentication cache is enabled or not.
    authCacheEnabled: true
    # The maximum size of the cache, after which a purge takes place
    authCacheMaxSize: 1000
    # The proportion (0 to 1) of entries that remain in the cache after the cache is purged due to overpopulation
    authCachePurgeRetentionRatio: 0.75
    # Whether to allow non-admins to perform non channel scoped queries.
    # When this is false, it means that only peer admins can perform non channel scoped queries.
    orgMembersAllowedAccess: false

  # Limits is used to configure some internal resource limits.
  limits:
    # Concurrency limits the number of concurrently running requests to a service on each peer.
    # Currently this option is only applied to endorser service and deliver service.
    # When the property is missing or the value is 0, the concurrency limit is disabled for the service.
    concurrency:
      # endorserService limits concurrent requests to endorser service that handles chaincode deployment, query and invocation,
      # including both user chaincodes and system chaincodes.
      endorserService: 2500
      # deliverService limits concurrent event listeners registered to deliver service for blocks and transaction events.
      deliverService: 2500
      # gatewayService limits concurrent requests to gateway service that handles the submission and evaluation of transactions.
      gatewayService: 500

  # Since all nodes should be consistent it is recommended to keep
  # the default value of 100MB for MaxRecvMsgSize & MaxSendMsgSize
  # Max message size in bytes GRPC server and client can receive
  maxRecvMsgSize: 104857600
  # Max message size in bytes GRPC server and client can send
  maxSendMsgSize: 104857600

###############################################################################
#
#    VM section
#
###############################################################################
vm:
  # Endpoint of the vm management system.  For docker can be one of the following in general
  # unix:///var/run/docker.sock
  # http://localhost:2375
  # https://localhost:2376
  # If you utilize external chaincode builders and don't need the default Docker chaincode builder,
  # the endpoint should be unconfigured so that the peer's Docker health checker doesn't get registered.
  endpoint: unix:///var/run/docker.sock

  # settings for docker vms
  docker:
    tls:
      enabled: false
      ca:
        file: docker/ca.crt
      cert:
        file: docker/tls.crt
      key:
        file: docker/tls.key

    # Enables/disables the standard out/err from chaincode containers for
    # debugging purposes
    attachStdout: false

    # Parameters on creating docker container.
    # Container may be efficiently created using ipam & dns-server for cluster
    # NetworkMode - sets the networking mode for the container. Supported
    # standard values are: `host`(default),`bridge`,`ipvlan`,`none`.
    # Dns - a list of DNS servers for the container to use.
    # Note:  `Privileged` `Binds` `Links` and `PortBindings` properties of
    # Docker Host Config are not supported and will not be used if set.
    # LogConfig - sets the logging driver (Type) and related options
    # (Config) for Docker. For more info,
    # https://docs.docker.com/engine/admin/logging/overview/
    # Note: Set LogConfig using Environment Variables is not supported.
    hostConfig:
      NetworkMode: host
      Dns:
        # - 192.168.0.1
      LogConfig:
        Type: json-file
        Config:
          max-size: "50m"
          max-file: "5"
      Memory: 2147483648

###############################################################################
#
#    Chaincode section
#
###############################################################################
chaincode:
  # The id is used by the Chaincode stub to register the executing Chaincode
  # ID with the Peer and is generally supplied through ENV variables
  # the `path` form of ID is provided when installing the chaincode.
  # The `name` is used for all other requests and can be any string.
  id:
    path:
    name:

  # Generic builder image with Go pre-installed.
  # TWO_DIGIT_VERSION represents Fabric major.minor version.
  builder: $(DOCKER_NS)/fabric-ccenv:$(TWO_DIGIT_VERSION)

  # Enables/disables force pulling of the base docker images (listed below)
  # during user chaincode instantiation.
  # Useful when using moving image tags (such as :latest)
  pull: false

  golang:
    # Compiled Go chaincodes will be copied to the fabric-baseos runtime image.
    # TWO_DIGIT_VERSION represents Fabric major.minor version.
    runtime: $(DOCKER_NS)/fabric-baseos:$(TWO_DIGIT_VERSION)

    # whether or not golang chaincode should be linked dynamically
    dynamicLink: false

  java:
    # This is an image based on eclipse temurin with addition compiler
    # tools added for java shim layer packaging.
    # This image is packed with shim layer libraries that are necessary
    # for Java chaincode runtime.
    runtime: $(DOCKER_NS)/fabric-javaenv:2.5

  node:
    # This is an image based on node:$(NODE_VER)-alpine
    runtime: $(DOCKER_NS)/fabric-nodeenv:2.5

  # List of directories to treat as external builders and launchers for
  # chaincode. The external builder detection processing will iterate over the
  # builders in the order specified below.
  # If you don't need to fallback to the default Docker builder, also unconfigure vm.endpoint above.
  # To override this property via env variable use CORE_CHAINCODE_EXTERNALBUILDERS: [{name: x, path: dir1}, {name: y, path: dir2}]
  # The path must be an absolute path.
  externalBuilders:
    - name: ccaas_builder
      path: /opt/hyperledger/ccaas_builder
      propagateEnvironment:
        - CHAINCODE_AS_A_SERVICE_BUILDER_CONFIG

  # The maximum duration to wait for the chaincode build and install process
  # to complete.
  installTimeout: 300s

  # Timeout duration for starting up a container and waiting for Register
  # to come through.
  startuptimeout: 300s

  # Timeout duration for Invoke and Init calls to prevent runaway.
  # This timeout is used by all chaincodes in all the channels, including
  # system chaincodes.
  # Note that during Invoke, if the image is not available (e.g. being
  # cleaned up when in development environment), the peer will automatically
  # build the image, which might take more time. In production environment,
  # the chaincode image is unlikely to be deleted, so the timeout could be
  # reduced accordingly.
  executetimeout: 30s

  # There are 2 modes: "dev" and "net".
  # In dev mode, user runs the chaincode after starting peer from
  # command line on local machine.
  # In net mode, peer will run chaincode in a docker container.
  mode: net

  # keepalive in seconds. In situations where the communication goes through a
  # proxy that does not support keep-alive, this parameter will maintain connection
  # between peer and chaincode.
  # A value <= 0 turns keepalive off
  keepalive: 0

  # enabled system chaincodes
  system:
    _lifecycle: enable
    cscc: enable
    lscc: enable
    qscc: enable

  # Logging section for the chaincode container
  logging:
    # Default level for all loggers within the chaincode container
    level: info
    # Override default level for the 'shim' logger
    shim: warning
    # Format for the chaincode container logs
    format: "%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -> %{level:.4s} %{id:03x}%{color:reset} %{message}"

    # RuntimeParams section for parameters that are passed to chaincode
    # to specify additional operation modes in which the peer operates.
  runtimeParams:
    # UseWriteBatch an indication that the peer can accept changes from chaincode in batches
    useWriteBatch: true
    # MaxSizeWriteBatch maximum batch size for the change segment
    maxSizeWriteBatch: 1000
    # UseGetMultipleKeys an indication that the peer can handle get multiple keys
    useGetMultipleKeys: true
    # MaxSizeGetMultipleKeys maximum size of batches with get multiple keys
    maxSizeGetMultipleKeys: 1000

###############################################################################
#
#    Ledger section - ledger configuration encompasses both the blockchain
#    and the state
#
###############################################################################
ledger:
  blockchain:

  state:
    # stateDatabase - options are "goleveldb", "CouchDB"
    # goleveldb - default state database stored in goleveldb.
    # CouchDB - store state database in CouchDB
    stateDatabase: goleveldb
    # Limit on the number of records to return per query
    totalQueryLimit: 100000
    couchDBConfig:
      # It is recommended to run CouchDB on the same server as the peer, and
      # not map the CouchDB container port to a server port in docker-compose.
      # Otherwise proper security must be provided on the connection between
      # CouchDB client (on the peer) and server.
      couchDBAddress: 127.0.0.1:5984
      # This username must have read and write authority on CouchDB
      username:
      # The password is recommended to pass as an environment variable
      # during start up (eg CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD).
      # If it is stored here, the file must be access control protected
      # to prevent unintended users from discovering the password.
      password:
      # Number of retries for CouchDB errors
      maxRetries: 3
      # Number of retries for CouchDB errors during peer startup.
      # The delay between retries doubles for each attempt.
      # Default of 10 retries results in 11 attempts over 2 minutes.
      maxRetriesOnStartup: 10
      # CouchDB request timeout (unit: duration, e.g. 20s)
      requestTimeout: 35s
      # Limit on the number of records per each CouchDB query
      # Note that chaincode queries are only bound by totalQueryLimit.
      # Internally the chaincode may execute multiple CouchDB queries,
      # each of size internalQueryLimit.
      internalQueryLimit: 1000
      # Limit on the number of records per CouchDB bulk update batch
      maxBatchUpdateSize: 1000
      # Create the _global_changes system database
      # This is optional.  Creating the global changes database will require
      # additional system resources to track changes and maintain the database
      createGlobalChangesDB: false
      # CacheSize denotes the maximum mega bytes (MB) to be allocated for the in-memory state
      # cache. Note that CacheSize needs to be a multiple of 32 MB. If it is not a multiple
      # of 32 MB, the peer would round the size to the next multiple of 32 MB.
      # To disable the cache, 0 MB needs to be assigned to the cacheSize.
      cacheSize: 64

  history:
    # enableHistoryDatabase - options are true or false
    # Indicates if the history of key updates should be stored.
    # All history 'index' will be stored in goleveldb, regardless if using
    # CouchDB or alternate database for the state.
    enableHistoryDatabase: true

  pvtdataStore:
    # the maximum db batch size for converting
    # the ineligible missing data entries to eligible missing data entries
    collElgProcMaxDbBatchSize: 5000
    # the minimum duration (in milliseconds) between writing
    # two consecutive db batches for converting the ineligible missing data entries to eligible missing data entries
    collElgProcDbBatchesInterval: 1000
    # The missing data entries are classified into two categories:
    # (1) prioritized
    # (2) deprioritized
    # Initially, all missing data are in the prioritized list. When the
    # reconciler is unable to fetch the missing data from other peers,
    # the unreconciled missing data would be moved to the deprioritized list.
    # The reconciler would retry deprioritized missing data after every
    # deprioritizedDataReconcilerInterval (unit: minutes). Note that the
    # interval needs to be greater than the reconcileSleepInterval
    deprioritizedDataReconcilerInterval: 60m
    # The frequency to purge private data (in number of blocks).
    # Private data is purged from the peer's private data store based on
    # the collection property blockToLive or an explicit chaincode call to PurgePrivateData().
    purgeInterval: 100
    # Whether to log private data keys purged from private data store (INFO level) when explicitly purged via chaincode
    purgedKeyAuditLogging: true

  snapshots:
    # Path on the file system where peer will store ledger snapshots
    # The path must be an absolute path.
    rootDir: /var/hyperledger/production/snapshots

###############################################################################
#
#    Operations section
#
###############################################################################
operations:
  # host and port for the operations server
  listenAddress: 127.0.0.1:9443

  # TLS configuration for the operations endpoint
  tls:
    # TLS enabled
    enabled: false

    # path to PEM encoded server certificate for the operations server
    # The paths in this section may be relative to FABRIC_CFG_PATH or an absolute path.
    cert:
      file:

    # path to PEM encoded server key for the operations server
    key:
      file:

    # most operations service endpoints require client authentication when TLS
    # is enabled. clientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    clientAuthRequired: false

    # paths to PEM encoded ca certificates to trust for client authentication
    clientRootCAs:
      files: []

###############################################################################
#
#    Metrics section
#
###############################################################################
metrics:
  # metrics provider is one of statsd, prometheus, or disabled
  provider: disabled

  # statsd configuration
  statsd:
    # network type: tcp or udp
    network: udp

    # statsd server address
    address: 127.0.0.1:8125

    # the interval at which locally cached counters and gauges are pushed
    # to statsd; timings are pushed immediately
    writeInterval: 10s

    # prefix is prepended to all emitted statsd metrics
    prefix:



./config/network.yaml
----------------------------------------
network:
  name: "my-fabric-network"
  domain: "example.com"
  version: "3.1.1"

organizations:
  - name: "Org1"
    msp_id: "Org1MSP"
    peers:
      - name: "peer0"
        port: 7051
        chaincode_port: 7052
      - name: "peer1"
        port: 8051
        chaincode_port: 8052
    ca:
      port: 7054

  - name: "Org2"
    msp_id: "Org2MSP"
    peers:
      - name: "peer0"
        port: 9051
        chaincode_port: 9052
    ca:
      port: 8054

orderer:
  type: "etcdraft"
  nodes:
    - name: "orderer0"
      port: 7050
      admin_port: 7053

channels:
  - name: "mychannel"
    participating_orgs: ["Org1", "Org2"]

chaincodes:
  - name: "basic_asset"
    version: "1.0"
    pdc: # Defini√ß√£o de Private Data Collections
      - name: "collectionMarbles"
        policy: "OR('Org1MSP.member', 'Org2MSP.member')"
        required_peer_count: 1
        max_peer_count: 2
        block_to_live: 1000


./config/versions.yaml
----------------------------------------
# Defini√ß√µes de Vers√£o para o Ambiente Hyperledger Fabric
versions:
  fabric: "3.1.1"           # Vers√£o dos bin√°rios e imagens peer/orderer
  fabric_ca: "1.5.13"       # Vers√£o da CA (geralmente tem versionamento pr√≥prio)
  go: "1.22.0"              # Fabric 3.x requer Go 1.22+
  docker: "20.10"           # Vers√£o m√≠nima do Docker
  docker_compose: "2.20"    # Vers√£o m√≠nima do Docker Compose (V2)

# Configura√ß√µes globais de imagem
images:
  org_hyperledger: "hyperledger" # Prefixo da imagem docker


./config/orderer.yaml
----------------------------------------
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

---
################################################################################
#
#   Orderer Configuration
#
#   - This controls the type and configuration of the orderer.
#
################################################################################
General:
  # Listen address: The IP on which to bind to listen.
  ListenAddress: 127.0.0.1

  # Listen port: The port on which to bind to listen.
  ListenPort: 7050

  # TLS: TLS settings for the GRPC server.
  TLS:
    # Require server-side TLS
    Enabled: false
    # PrivateKey governs the file location of the private key of the TLS certificate.
    PrivateKey: tls/server.key
    # Certificate governs the file location of the server TLS certificate.
    Certificate: tls/server.crt
    # RootCAs contains a list of additional root certificates used for verifying certificates
    # of other orderer nodes during outbound connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    RootCAs:
      - tls/ca.crt
    # Require client certificates / mutual TLS for inbound connections.
    ClientAuthRequired: false
    # If mutual TLS is enabled, ClientRootCAs contains a list of additional root certificates
    # used for verifying certificates of client connections.
    # It is not required to be set, but can be used to augment the set of TLS CA certificates
    # available from the MSPs of each channel‚Äôs configuration.
    ClientRootCAs:
  # Keepalive settings for the GRPC server.
  Keepalive:
    # ServerMinInterval is the minimum permitted time between client pings.
    # If clients send pings more frequently, the server will
    # disconnect them.
    ServerMinInterval: 60s
    # ServerInterval is the time between pings to clients.
    ServerInterval: 7200s
    # ServerTimeout is the duration the server waits for a response from
    # a client before closing the connection.
    ServerTimeout: 20s
  # Config defines the configuration options for backoff GRPC client.
  Backoff:
    # BaseDelay is the amount of time to backoff after the first failure.
    BaseDelay: 1s
    # Multiplier is the factor with which to multiply backoffs after a
    # failed retry. Should ideally be greater than 1.
    Multiplier: 1.6
    # MaxDelay is the upper bound of backoff delay.
    MaxDelay: 2m

  # Since all nodes should be consistent it is recommended to keep
  # the default value of 100MB for MaxRecvMsgSize & MaxSendMsgSize
  # Max message size in bytes the GRPC server and client can receive
  MaxRecvMsgSize: 104857600
  # Max message size in bytes the GRPC server and client can send
  MaxSendMsgSize: 104857600
  # Throttling prevents clients from sending too many transactions
  # per second to the broadcast API of this node.
  # It is only enforced when the Rate is non-zero, and when the client
  # connects using mutual TLS.
  # The effective rate of transactions is divided across all clients
  # and organizations at a given unit of time governed by the inactivity timeout.
  # When a client's rate of transaction submission exhausts its allocated budget,
  # it is throttled until additional "budget" is allocated (it is allocated once per second).
  Throttling:
    # Rate is the maximum rate (transactions per second) for all clients combined.
    # A zero rate disables throttling.
    Rate: 0
    # InactivityTimeout defines the time frame after which
    # inactive clients are pruned from memory and are not considered
    # when allocating the budget for throttling per client.
    InactivityTimeout: 5s

  # Cluster settings for ordering service nodes that communicate with other ordering service nodes
  # such as Raft based ordering service.
  Cluster:
    # SendBufferSize is the maximum number of messages in the egress buffer.
    # Consensus messages are dropped if the buffer is full, and transaction
    # messages are waiting for space to be freed.
    SendBufferSize: 100

    # ClientCertificate governs the file location of the client TLS certificate
    # used to establish mutual TLS connections with other ordering service nodes.
    # If not set, the server General.TLS.Certificate is re-used.
    ClientCertificate:
    # ClientPrivateKey governs the file location of the private key of the client TLS certificate.
    # If not set, the server General.TLS.PrivateKey is re-used.
    ClientPrivateKey:

    # The below 4 properties should be either set together, or be unset together.
    # If they are set, then the orderer node uses a separate listener for intra-cluster
    # communication. If they are unset, then the general orderer listener is used.
    # This is useful if you want to use a different TLS server certificates on the
    # client-facing and the intra-cluster listeners.

    # ListenPort defines the port on which the cluster listens to connections.
    ListenPort:
    # ListenAddress defines the IP on which to listen to intra-cluster communication.
    ListenAddress:
    # ServerCertificate defines the file location of the server TLS certificate used for intra-cluster
    # communication.
    ServerCertificate:
    # ServerPrivateKey defines the file location of the private key of the TLS certificate.
    ServerPrivateKey:

    # ReplicationPolicy defines how blocks are replicated between orderers.
    # Permitted values:
    # in BFT: "simple" | "consensus" (default);
    # in etcdraft: ignored, (always "simple", regardless of value in config).
    # When running a Raft orderer or with ReplicationPolicy set to 'simple', an orderer
    # replicates blocks from a single orderer node.
    # When running a BFT orderer with ReplicationPolicy set to 'consensus', the orderer
    # replicates blocks from a single orderer node, but replicates block headers with signatures
    # from other orderer nodes, and if it suspects the former node withholds blocks from it,
    # it switches to a new orderer as a source of blocks.
    ReplicationPolicy:

  # LocalMSPDir is where to find the private crypto material needed by the
  # orderer. It is set relative here as a default for dev environments but
  # should be changed to the real location in production.
  LocalMSPDir: msp

  # LocalMSPID is the identity to register the local MSP material with the MSP
  # manager. The sample organization defined in the
  # sample configuration provided has an MSP ID of "SampleOrg".
  LocalMSPID: SampleOrg

  # Enable an HTTP service for Go "pprof" profiling as documented at:
  # https://golang.org/pkg/net/http/pprof
  Profile:
    Enabled: false
    Address: 0.0.0.0:6060

  # BCCSP configures the blockchain crypto service providers.
  BCCSP:
    # Default specifies the preferred blockchain crypto service provider
    # to use. If the preferred provider is not available, the software
    # based provider ("SW") will be used.
    # Valid providers are:
    #  - SW: a software based crypto provider
    #  - PKCS11: a CA hardware security module crypto provider.
    Default: SW

    # SW configures the software based blockchain crypto provider.
    SW:
      # TODO: The default Hash and Security level needs refactoring to be
      # fully configurable. Changing these defaults requires coordination
      # SHA2 is hardcoded in several places, not only BCCSP
      Hash: SHA2
      Security: 256
      # Location of key store. If this is unset, a location will be
      # chosen using: 'LocalMSPDir'/keystore
      FileKeyStore:
        KeyStore:

    # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)
    PKCS11:
      # Location of the PKCS11 module library
      Library:
      # Token Label
      Label:
      # User PIN
      Pin:
      Hash:
      Security:
      FileKeyStore:
        KeyStore:

  # Authentication contains configuration parameters related to authenticating
  # client messages
  Authentication:
    # the acceptable difference between the current server time and the
    # client's time as specified in a client request message
    TimeWindow: 15m

################################################################################
#
#   SECTION: File Ledger
#
#   - This section applies to the configuration of the file ledger.
#
################################################################################
FileLedger:
  # Location: The directory to store the blocks in.
  Location: /var/hyperledger/production/orderer

################################################################################
#
#   Debug Configuration
#
#   - This controls the debugging options for the orderer
#
################################################################################
Debug:
  # BroadcastTraceDir when set will cause each request to the Broadcast service
  # for this orderer to be written to a file in this directory
  BroadcastTraceDir:

  # DeliverTraceDir when set will cause each request to the Deliver service
  # for this orderer to be written to a file in this directory
  DeliverTraceDir:

################################################################################
#
#   Operations Configuration
#
#   - This configures the operations server endpoint for the orderer
#
################################################################################
Operations:
  # host and port for the operations server
  ListenAddress: 127.0.0.1:8443

  # TLS configuration for the operations endpoint
  TLS:
    # TLS enabled
    Enabled: false

    # Certificate is the location of the PEM encoded TLS certificate
    Certificate:

    # PrivateKey points to the location of the PEM-encoded key
    PrivateKey:

    # Most operations service endpoints require client authentication when TLS
    # is enabled. ClientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    ClientAuthRequired: false

    # Paths to PEM encoded ca certificates to trust for client authentication
    ClientRootCAs: []

################################################################################
#
#   Metrics Configuration
#
#   - This configures metrics collection for the orderer
#
################################################################################
Metrics:
  # The metrics provider is one of statsd, prometheus, or disabled
  Provider: disabled

  # The statsd configuration
  Statsd:
    # network type: tcp or udp
    Network: udp

    # the statsd server address
    Address: 127.0.0.1:8125

    # The interval at which locally cached counters and gauges are pushed
    # to statsd; timings are pushed immediately
    WriteInterval: 30s

    # The prefix is prepended to all emitted statsd metrics
    Prefix:

################################################################################
#
#   Admin Configuration
#
#   - This configures the admin server endpoint for the orderer
#
################################################################################
Admin:
  # host and port for the admin server
  ListenAddress: 127.0.0.1:9443

  # TLS configuration for the admin endpoint
  TLS:
    # TLS enabled
    Enabled: false

    # Certificate is the location of the PEM encoded TLS certificate
    Certificate:

    # PrivateKey points to the location of the PEM-encoded key
    PrivateKey:

    # Most admin service endpoints require client authentication when TLS
    # is enabled. ClientAuthRequired requires client certificate authentication
    # at the TLS layer to access all resources.
    #
    # NOTE: When TLS is enabled, the admin endpoint requires mutual TLS. The
    # orderer will panic on startup if this value is set to false.
    ClientAuthRequired: true

    # Paths to PEM encoded ca certificates to trust for client authentication
    ClientRootCAs: []

################################################################################
#
#   Channel participation API Configuration
#
#   - This provides the channel participation API configuration for the orderer.
#   - Channel participation uses the ListenAddress and TLS settings of the Admin
#     service.
#
################################################################################
ChannelParticipation:
  # Channel participation API is enabled. Deprecated: must be set to true.
  Enabled: true

  # The maximum size of the request body when joining a channel.
  MaxRequestBodySize: 1 MB

################################################################################
#
#   Consensus Configuration
#
#   - This section contains config options for a consensus plugin. It is opaque
#     to orderer, and completely up to consensus implementation to make use of.
#
################################################################################
Consensus:
  # The allowed key-value pairs here depend on consensus plugin. For etcd/raft,
  # we use following options:

  # WALDir specifies the location at which Write Ahead Logs for etcd/raft are
  # stored. Each channel will have its own subdir named after channel ID.
  WALDir: /var/hyperledger/production/orderer/etcdraft/wal

  # SnapDir specifies the location at which snapshots for etcd/raft are
  # stored. Each channel will have its own subdir named after channel ID.
  SnapDir: /var/hyperledger/production/orderer/etcdraft/snapshot



./scripts/check_reqs.sh
----------------------------------------
#!/bin/bash

source ./scripts/colors.sh

# Define o diret√≥rio raiz do projeto
# Se NETWORK_DIR vier do Python, usamos o pai dele como raiz, ou o diret√≥rio atual
PROJECT_ROOT=${NETWORK_DIR%/network} # Remove '/network' do final para pegar a raiz
if [ -z "$PROJECT_ROOT" ]; then
    PROJECT_ROOT="."
fi

# Adiciona ./bin local ao PATH temporariamente para verifica√ß√£o
export PATH=$PROJECT_ROOT/bin:$PATH

infoln "Verificando pr√©-requisitos para Fabric $FABRIC_VERSION e CA $CA_VERSION..."

# ---------------------------------------------------------
# 1. Verificar Docker
# ---------------------------------------------------------
if ! command -v docker &> /dev/null; then
    errorln "Docker n√£o encontrado! Instale o Docker Desktop ou Engine."
    exit 1
fi
DOCKER_V=$(docker --version)
successln "Docker encontrado: $DOCKER_V"

# ---------------------------------------------------------
# 2. Verificar Go (Opcional)
# ---------------------------------------------------------
if command -v go &> /dev/null; then
    CURRENT_GO=$(go version | awk '{print $3}' | sed 's/go//')
    if [[ "$CURRENT_GO" < "$GO_VERSION" ]]; then
        warnln "AVISO: Vers√£o do Go ($CURRENT_GO) √© menor que a recomendada ($GO_VERSION)"
    else
        successln "Go vers√£o $CURRENT_GO compat√≠vel."
    fi
else
    warnln "Go n√£o instalado (OK se n√£o for compilar Chaincode em Go)"
fi

# ---------------------------------------------------------
# 3. Verificar e Baixar Bin√°rios do Fabric
# ---------------------------------------------------------

NEED_INSTALL=false

if command -v configtxgen &> /dev/null; then
    FABRIC_BIN_VER=$(configtxgen -version | grep "Version:" | awk '{print $2}')
    
    if [[ "$FABRIC_BIN_VER" != "$FABRIC_VERSION" ]]; then
        warnln "Vers√£o local ($FABRIC_BIN_VER) difere da desejada ($FABRIC_VERSION)."
        NEED_INSTALL=true
    else
        successln "Bin√°rios do Fabric ($FABRIC_BIN_VER) j√° instalados corretamente."
    fi
else
    warnln "Bin√°rios do Fabric n√£o encontrados no PATH."
    NEED_INSTALL=true
fi

if [ "$NEED_INSTALL" = true ]; then
    infoln "Iniciando download dos bin√°rios do Fabric $FABRIC_VERSION..."
    
    # Entra na raiz do projeto
    pushd "$PROJECT_ROOT" > /dev/null

    # Baixa o script oficial
    curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh -o install-fabric.sh
    chmod +x install-fabric.sh

    # Executa a instala√ß√£o
    ./install-fabric.sh --fabric-version $FABRIC_VERSION --ca-version $CA_VERSION binary docker

    # Limpeza
    rm install-fabric.sh
    
    popd > /dev/null
    
    successln "Download e instala√ß√£o conclu√≠dos na pasta bin/ local."
fi

successln "--- Script check_reqs rodado com sucesso ---\n"


./scripts/colors.sh
----------------------------------------
#!/bin/bash

# Cores ANSI
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[1;33m"
BLUE="\033[0;34m"
CYAN="\033[0;36m"
RESET="\033[0m"

# Fun√ß√£o de info (azul)
infoln() {
    echo -e "${BLUE}[INFO] $1${RESET}"
}

# Fun√ß√£o de sucesso (verde)
successln() {
    echo -e "${GREEN}[SUCESSO] $1${RESET}"
}

# Fun√ß√£o de aviso (amarelo)
warnln() {
    echo -e "${YELLOW}[AVISO] $1${RESET}"
}

# Fun√ß√£o de erro (vermelho)
errorln() {
    echo -e "${RED}[ERRO] $1${RESET}"
}



./main.py
----------------------------------------
from src.path_manager import PathManager
from src.config_loader import ConfigLoader
from src.network_controller import NetworkController
from src.colors import Colors as co

def main():
    # 1. Configurar Caminhos
    paths = PathManager()

    # 2. Carregar Configura√ß√µes
    loader = ConfigLoader(paths.network_yaml, paths.versions_yaml)
    config = loader.load()

    # 3. Inicializar Controlador
    controller = NetworkController(config, paths)

    # 4. Verifica vers√µes e pr√©-requisitos
    try:
        controller.run_script("check_reqs.sh")
    except Exception as e:
        co.errorln(f"\n Erro nos pr√©-requisitos: {e}")
        return

if __name__ == "__main__":
    main()


